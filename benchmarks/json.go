// Code generated by langlang (unknown commit hash), DO NOT EDIT.
// Source File: ../grammars/json.peg
package benchmarks

import (
	"encoding/hex"
	"fmt"
	"math/bits"
	"sort"
	"strconv"
	"strings"
	"unicode/utf8"
)

type Matcher interface {
	Match([]byte) (Tree, int, error)

	SourceMap() *SourceMap
}
type NodeID uint32
type NodeType uint8

const (
	NodeType_String NodeType = iota

	NodeType_Sequence

	NodeType_Node

	NodeType_Error
)

type Location struct {
	Line   int
	Column int
	Cursor int
}
type Span struct {
	Start Location
	End   Location
}
type Tree interface {
	Root() (NodeID, bool)

	Visit(id NodeID, fn func(NodeID) bool)

	Type(NodeID) NodeType

	Span(NodeID) Span

	Location(cursor int) Location

	CursorU16(cursor int) int

	Name(NodeID) string

	Message(NodeID) string

	Child(NodeID) (NodeID, bool)

	Children(NodeID) []NodeID

	Text(NodeID) string

	Pretty(NodeID) string

	Highlight(NodeID) string

	Copy() Tree
}
type ImportLoader interface {
	GetPath(importPath, parentPath string) (string, error)

	GetContent(path string) ([]byte, error)
}
type FileID int
type SourceLocation struct {
	FileID FileID
	Span   Span
}
type DiagnosticSeverity int

const (
	DiagnosticError DiagnosticSeverity = iota
	DiagnosticWarning
	DiagnosticInfo
	DiagnosticHint
)

type Diagnostic struct {
	Location SourceLocation
	Severity DiagnosticSeverity
	Message  string
	Code     string
	FilePath string
	Expected []ErrHint
}
type SourceMap struct {
	Data    []byte
	Files   []string
	entries []srcMapEntry
}

var bytecodeForParser = &Bytecode{
	code: []byte{
		11, 5, 0, 0, 0, 15, 16, 0, 18, 0, 0, 6, 21, 0, 11, 43, 0, 0, 8, 24, 0, 14, 1, 0, 18, 0, 0, 6, 38, 0, 7, 35, 0, 1, 5, 8, 41, 0, 14, 2, 0, 16, 12, 15, 18, 0, 6, 56, 0, 11, 246, 1, 0, 8, 162, 1, 6, 66, 0, 11, 164, 1, 0, 8, 162, 1, 6, 223, 0, 15, 22, 0, 18, 0, 0, 17, 1, 0, 19, 1, 0, 6, 204, 0, 15, 24, 0, 6, 104, 0, 17, 2, 0, 17, 3, 0, 20, 25, 0, 2, 0, 8, 200, 0, 6, 194, 0, 15, 26, 0, 17, 2, 0, 19, 1, 0, 17, 4, 0, 19, 1, 0, 6, 136, 0, 17, 5, 0, 20, 27, 0, 1, 0, 8, 139, 0, 14, 12, 0, 6, 153, 0, 17, 5, 0, 20, 27, 0, 1, 0, 8, 156, 0, 14, 13, 0, 6, 170, 0, 17, 5, 0, 20, 27, 0, 1, 0, 8, 173, 0, 14, 14, 0, 6, 187, 0, 17, 5, 0, 20, 27, 0, 1, 0, 8, 190, 0, 14, 15, 0, 16, 8, 200, 0, 17, 6, 0, 19, 1, 0, 16, 9, 84, 0, 6, 216, 0, 17, 1, 0, 19, 1, 0, 8, 219, 0, 14, 11, 0, 16, 8, 162, 1, 6, 109, 1, 15, 28, 0, 18, 0, 0, 6, 244, 0, 17, 7, 0, 19, 1, 0, 8, 244, 0, 26, 29, 0, 6, 0, 1, 17, 8, 0, 8, 6, 1, 17, 9, 0, 18, 10, 0, 27, 6, 50, 1, 15, 30, 0, 17, 11, 0, 19, 1, 0, 6, 43, 1, 17, 10, 0, 19, 1, 0, 6, 40, 1, 17, 10, 0, 19, 1, 0, 9, 31, 1, 8, 46, 1, 14, 9, 0, 16, 8, 50, 1, 6, 105, 1, 15, 31, 0, 17, 12, 0, 19, 1, 0, 6, 74, 1, 17, 13, 0, 19, 1, 0, 8, 74, 1, 6, 98, 1, 17, 10, 0, 19, 1, 0, 6, 95, 1, 17, 10, 0, 19, 1, 0, 9, 86, 1, 8, 101, 1, 14, 10, 0, 16, 8, 105, 1, 16, 8, 162, 1, 25, 6, 128, 1, 2, 116, 0, 2, 114, 0, 2, 117, 0, 2, 101, 0, 8, 161, 1, 6, 149, 1, 2, 102, 0, 2, 97, 0, 2, 108, 0, 2, 115, 0, 2, 101, 0, 8, 161, 1, 2, 110, 0, 2, 117, 0, 2, 108, 0, 2, 108, 0, 27, 16, 12, 15, 21, 0, 18, 0, 0, 17, 14, 0, 19, 1, 0, 18, 0, 0, 6, 226, 1, 18, 0, 0, 11, 43, 0, 0, 6, 223, 1, 18, 0, 0, 18, 0, 0, 17, 15, 0, 19, 1, 0, 18, 0, 0, 6, 217, 1, 11, 43, 0, 0, 8, 220, 1, 14, 3, 0, 9, 192, 1, 8, 226, 1, 18, 0, 0, 6, 241, 1, 17, 16, 0, 19, 1, 0, 8, 244, 1, 14, 4, 0, 16, 12, 15, 20, 0, 18, 0, 0, 17, 17, 0, 19, 1, 0, 18, 0, 0, 6, 52, 2, 18, 0, 0, 11, 72, 2, 0, 6, 49, 2, 18, 0, 0, 18, 0, 0, 17, 15, 0, 19, 1, 0, 18, 0, 0, 6, 43, 2, 11, 72, 2, 0, 8, 46, 2, 14, 5, 0, 9, 18, 2, 8, 52, 2, 18, 0, 0, 6, 67, 2, 17, 18, 0, 19, 1, 0, 8, 70, 2, 14, 6, 0, 16, 12, 15, 32, 0, 18, 0, 0, 15, 22, 0, 18, 0, 0, 17, 1, 0, 19, 1, 0, 6, 213, 2, 15, 24, 0, 6, 113, 2, 17, 2, 0, 17, 3, 0, 20, 25, 0, 2, 0, 8, 209, 2, 6, 203, 2, 15, 26, 0, 17, 2, 0, 19, 1, 0, 17, 4, 0, 19, 1, 0, 6, 145, 2, 17, 5, 0, 20, 27, 0, 1, 0, 8, 148, 2, 14, 12, 0, 6, 162, 2, 17, 5, 0, 20, 27, 0, 1, 0, 8, 165, 2, 14, 13, 0, 6, 179, 2, 17, 5, 0, 20, 27, 0, 1, 0, 8, 182, 2, 14, 14, 0, 6, 196, 2, 17, 5, 0, 20, 27, 0, 1, 0, 8, 199, 2, 14, 15, 0, 16, 8, 209, 2, 17, 6, 0, 19, 1, 0, 16, 9, 93, 2, 6, 225, 2, 17, 1, 0, 19, 1, 0, 8, 228, 2, 14, 11, 0, 16, 18, 0, 0, 6, 244, 2, 17, 19, 0, 19, 1, 0, 8, 247, 2, 14, 7, 0, 18, 0, 0, 6, 4, 3, 11, 43, 0, 0, 8, 7, 3, 14, 8, 0, 16, 12, 15, 2, 0, 6, 19, 3, 1, 9, 15, 3, 16, 12, 15, 3, 0, 18, 20, 0, 16, 12, 15, 5, 0, 18, 21, 0, 16, 12, 15, 8, 0, 18, 21, 0, 16, 12, 15, 7, 0, 16, 12, 15, 4, 0, 16, 12, 15, 6, 0, 16, 12, 15, 11, 0, 16, 12, 15, 1, 0, 16, 12,
	},
	strs: []string{
		"", "jsonValue", "eof", "itemAfterComma", "arrayClose", "memberAfterComma", "objectClose", "memberColon", "memberValue", "fracDigits", "expDigits", "strClose", "chrH1", "chrH2", "chrH3", "chrH4", "JSON", "Spacing", "Value", "EOF", "Object", "Array", "String", "", "Char", "Escape", "Unicode", "Hex", "Number", "Int", "Frac", "Exp", "Member", "Space", "EOL",
	},
	rxps: map[int]int{
		1: 833, 2: 777, 3: 789, 4: 818, 5: 797, 6: 823, 7: 813, 8: 805, 11: 828,
	},
	rxbs: bitset512{
		2558, 0, 0, 0, 0, 0, 0, 0,
	},

	smap: map[string]int{
		"": 23, "Array": 21, "Char": 24, "EOF": 19, "EOL": 34, "Escape": 25, "Exp": 31, "Frac": 30, "Hex": 27, "Int": 29, "JSON": 16, "Member": 32, "Number": 28, "Object": 20, "Space": 33, "Spacing": 17, "String": 22, "Unicode": 26, "Value": 18, "arrayClose": 4, "chrH1": 12, "chrH2": 13, "chrH3": 14, "chrH4": 15, "eof": 2, "expDigits": 10, "fracDigits": 9, "itemAfterComma": 3, "jsonValue": 1, "memberAfterComma": 5, "memberColon": 7, "memberValue": 8, "objectClose": 6, "strClose": 11,
	},
	sets: []charset{
		{bits: [32]byte{0, 38, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
		{bits: [32]byte{0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
		{bits: [32]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
		{bits: [32]byte{0, 0, 0, 0, 4, 128, 0, 0, 0, 0, 0, 16, 68, 64, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
		{bits: [32]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
		{bits: [32]byte{0, 0, 0, 0, 0, 0, 255, 3, 126, 0, 0, 0, 126, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
		{bits: [32]byte{255, 255, 255, 255, 251, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}},
		{bits: [32]byte{0, 0, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
		{bits: [32]byte{0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
		{bits: [32]byte{0, 0, 0, 0, 0, 0, 254, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
		{bits: [32]byte{0, 0, 0, 0, 0, 0, 255, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
		{bits: [32]byte{0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
		{bits: [32]byte{0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
		{bits: [32]byte{0, 0, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
		{bits: [32]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
		{bits: [32]byte{0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
		{bits: [32]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
		{bits: [32]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
		{bits: [32]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
		{bits: [32]byte{0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
		{bits: [32]byte{255, 255, 255, 255, 255, 239, 255, 255, 255, 255, 255, 223, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}},
		{bits: [32]byte{255, 255, 255, 255, 255, 239, 255, 255, 255, 255, 255, 255, 255, 255, 255, 223, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}},
	},
	sexp: [][]expected{
		{{a: '\t'}, {a: '\n'}, {a: '\r'}, {a: ' '}},
		{{a: '"'}},
		{{a: '\\'}},
		{{a: '"'}, {a: '/'}, {a: '\\'}, {a: 'b'}, {a: 'f'}, {a: 'n'}, {a: 'r'}, {a: 't'}},
		{{a: 'u'}},
		{{a: '0', b: '9'}, {a: 'A', b: 'F'}, {a: 'a', b: 'f'}},
		{},
		{{a: '-'}},
		{{a: '0'}},
		{{a: '1', b: '9'}},
		{{a: '0', b: '9'}},
		{{a: '.'}},
		{{a: 'E'}, {a: 'e'}},
		{{a: '+'}, {a: '-'}},
		{{a: '['}},
		{{a: ','}},
		{{a: ']'}},
		{{a: '{'}},
		{{a: '}'}},
		{{a: ':'}},
		{},
		{},
	},
}

type Parser struct {
	input []byte
	vm    *virtualMachine
}

func NewParser() *Parser {
	vm := NewVirtualMachine(bytecodeForParser)
	return &Parser{vm: vm}
}
func (p *Parser) ParseJSON() (Tree, error)             { return p.parseFn(5) }
func (p *Parser) ParseValue() (Tree, error)            { return p.parseFn(43) }
func (p *Parser) ParseArray() (Tree, error)            { return p.parseFn(420) }
func (p *Parser) ParseObject() (Tree, error)           { return p.parseFn(502) }
func (p *Parser) ParseMember() (Tree, error)           { return p.parseFn(584) }
func (p *Parser) Parseeof() (Tree, error)              { return p.parseFn(777) }
func (p *Parser) ParseitemAfterComma() (Tree, error)   { return p.parseFn(789) }
func (p *Parser) ParsememberAfterComma() (Tree, error) { return p.parseFn(797) }
func (p *Parser) ParsememberValue() (Tree, error)      { return p.parseFn(805) }
func (p *Parser) ParsememberColon() (Tree, error)      { return p.parseFn(813) }
func (p *Parser) ParsearrayClose() (Tree, error)       { return p.parseFn(818) }
func (p *Parser) ParseobjectClose() (Tree, error)      { return p.parseFn(823) }
func (p *Parser) ParsestrClose() (Tree, error)         { return p.parseFn(828) }
func (p *Parser) ParsejsonValue() (Tree, error)        { return p.parseFn(833) }
func (p *Parser) Parse() (Tree, error)                 { return p.parseFn(5) }
func (p *Parser) SetInput(input []byte)                { p.input = input }
func (p *Parser) GetInput() []byte                     { return p.input }
func (p *Parser) SetLabelMessages(el map[int]int)      { p.vm.SetLabelMessages(el) }
func (p *Parser) SetShowFails(v bool)                  { p.vm.SetShowFails(v) }

func LabelMessagesForParser(labels map[string]string) map[int]int {
	return bytecodeForParser.CompileErrorLabels(labels)
}
func (p *Parser) parseFn(addr int) (Tree, error) {
	val, _, err := p.vm.MatchRule(p.input, addr)
	return val, err
}

const eof = -1

func NewLocation(line, column, cursor int) Location {
	return Location{Line: line, Column: column, Cursor: cursor}
}
func (l Location) String() string {
	return fmt.Sprintf("%d:%d", l.Line, l.Column)
}
func NewSpan(start, end Location) Span {
	return Span{Start: start, End: end}
}
func (s Span) Contains(other Span) bool {
	return s.Start.Cursor <= other.Start.Cursor && s.End.Cursor >= other.End.Cursor
}
func (s Span) String() string {
	startLoc := s.Start
	endLoc := s.End
	startLine, startCol := int(startLoc.Line), int(startLoc.Column)
	endLine, endCol := int(endLoc.Line), int(endLoc.Column)
	if startLine == endLine && endLine == startCol && endCol == endLine && startLine == 0 {
		startLine++
		endLine++
		startCol++
		endCol++
	}
	if startLine == endLine && startLine == 1 {
		if startCol == endCol {
			return fmt.Sprintf("%d", startCol)
		}
		return fmt.Sprintf("%d..%d", startCol, endCol)
	}
	if startLine == endLine && startCol == endCol {
		return fmt.Sprintf("%d:%d", startLine, startCol)
	}
	return fmt.Sprintf("%d:%d..%d:%d", startLine, startCol, endLine, endCol)
}

type srcMapEntry struct {
	offset                           int
	fileID                           int
	startLine, startCol, startCursor int
	endLine, endCol, endCursor       int
}
type posIndex struct {
	input []byte

	lineStart []int

	runeUnits, u16Units *unitsIndex
}

func newPosIndex(input []byte) *posIndex {

	lineStart := make([]int, 1, 64)
	lineStart[0] = 0
	for i, b := range input {
		if b == '\n' {

			lineStart = append(lineStart, i+1)
		}
	}
	return &posIndex{input: input, lineStart: lineStart}
}
func (pi *posIndex) LocationAt(cursor int) Location {
	if cursor < 0 {
		cursor = 0
	}
	if cursor > len(pi.input) {
		cursor = len(pi.input)
	}

	lineIdx := sort.Search(len(pi.lineStart), func(i int) bool {
		return pi.lineStart[i] > cursor
	}) - 1
	if lineIdx < 0 {
		lineIdx = 0
	}

	lineStart := pi.lineStart[lineIdx]

	pi.ensureRuneUnits()

	col := pi.runeUnits.UnitsAt(cursor) - pi.runeUnits.UnitsAt(lineStart) + 1

	return Location{
		Line:   lineIdx + 1,
		Column: col,
		Cursor: cursor,
	}
}
func (pi *posIndex) CursorAt(line0, col0 int) int {

	line := line0 + 1
	col := col0 + 1

	if line < 1 {
		line = 1
	}
	if col < 1 {
		col = 1
	}

	lineIdx := line - 1
	if lineIdx >= len(pi.lineStart) {

		return len(pi.input)
	}

	lineStart := pi.lineStart[lineIdx]

	var lineEnd int
	if lineIdx+1 < len(pi.lineStart) {
		lineEnd = pi.lineStart[lineIdx+1]
	} else {
		lineEnd = len(pi.input)
	}

	pi.ensureRuneUnits()

	startRunes := pi.runeUnits.UnitsAt(lineStart)
	targetRunes := startRunes + col - 1

	cursor := sort.Search(lineEnd-lineStart, func(i int) bool {
		return pi.runeUnits.UnitsAt(lineStart+i) >= targetRunes
	}) + lineStart

	if cursor > lineEnd {
		cursor = lineEnd
	}

	return cursor
}
func (pi *posIndex) CursorU16(cursor int) int {
	pi.ensureU16Units()
	return pi.u16Units.UnitsAt(cursor)
}
func (pi *posIndex) ensureRuneUnits() {
	if pi.runeUnits == nil {
		pi.runeUnits = newUnitsIndex(pi.input, unitsModeRune)
	}
}
func (pi *posIndex) ensureU16Units() {
	if pi.u16Units == nil {
		pi.u16Units = newUnitsIndex(pi.input, unitsModeUTF16)
	}
}

type unitsMode uint8

const (
	unitsModeRune unitsMode = iota
	unitsModeUTF16
)

type unitsIndex struct {
	input []byte

	byteOffsets []int

	unitOffsets []int

	mode unitsMode
}

func newUnitsIndex(input []byte, mode unitsMode) *unitsIndex {

	const strideBytes = 64

	var (
		unitCount            = 0
		bytesSinceCheckpoint = 0
		index                = &unitsIndex{
			input:       input,
			byteOffsets: make([]int, 0, 128),
			unitOffsets: make([]int, 0, 128),
			mode:        mode,
		}
	)

	index.byteOffsets = append(index.byteOffsets, 0)
	index.unitOffsets = append(index.unitOffsets, 0)

	for i := 0; i < len(input); {
		r, size := utf8.DecodeRune(input[i:])
		if size <= 0 {
			size = 1
			r = utf8.RuneError
		}

		i += size
		unitCount += index.unitsForRune(r)
		bytesSinceCheckpoint += size

		if bytesSinceCheckpoint >= strideBytes {
			index.byteOffsets = append(index.byteOffsets, i)
			index.unitOffsets = append(index.unitOffsets, unitCount)
			bytesSinceCheckpoint = 0
		}
	}

	if last := index.byteOffsets[len(index.byteOffsets)-1]; last != len(input) {
		index.byteOffsets = append(index.byteOffsets, len(input))
		index.unitOffsets = append(index.unitOffsets, unitCount)
	}
	return index
}
func (ix *unitsIndex) UnitsAt(cursor int) int {
	if cursor < 0 {
		cursor = 0
	}
	if cursor > len(ix.input) {
		cursor = len(ix.input)
	}

	i := sort.Search(len(ix.byteOffsets), func(i int) bool {
		return ix.byteOffsets[i] > cursor
	}) - 1
	if i < 0 {
		i = 0
	}

	bytePos := ix.byteOffsets[i]
	unitPos := ix.unitOffsets[i]

	for bytePos < cursor {
		r, size := utf8.DecodeRune(ix.input[bytePos:])
		if size <= 0 {
			size = 1
			r = utf8.RuneError
		}
		if bytePos+size > cursor {
			break
		}
		unitPos += ix.unitsForRune(r)
		bytePos += size
	}
	return unitPos
}
func (ix *unitsIndex) unitsForRune(r rune) int {
	switch ix.mode {
	case unitsModeRune:
		return 1
	case unitsModeUTF16:
		if r > 0xFFFF {
			return 2
		}
		return 1
	default:
		return 1
	}
}

type FormatToken int

const (
	FormatToken_None FormatToken = iota
	FormatToken_Range
	FormatToken_Literal
	FormatToken_Error
)

func (nt NodeType) String() string {
	switch nt {
	case NodeType_String:
		return "string"
	case NodeType_Sequence:
		return "sequence"
	case NodeType_Node:
		return "node"
	case NodeType_Error:
		return "error"
	default:
		return "unknown"
	}
}

type node struct {
	typ       NodeType
	start     int
	end       int
	nameID    int32
	childID   int32
	messageID int32
}
type tree struct {
	nodes       []node
	children    []NodeID
	childRanges []struct{ start, end int32 }
	strs        []string
	input       []byte
	root        NodeID
	posView     *posIndex
}

func (t *tree) bindInput(input []byte)    { t.input = input }
func (t *tree) bindStrings(strs []string) { t.strs = strs }
func (t *tree) reset() {
	t.nodes = t.nodes[:0]
	t.children = t.children[:0]
	t.childRanges = t.childRanges[:0]
	t.posView = nil
	t.root = 0
}
func (t *tree) Root() (NodeID, bool)                { return t.root, int(t.root) < len(t.nodes) }
func (t *tree) SetRoot(id NodeID)                   { t.root = id }
func (t *tree) Type(id NodeID) NodeType             { return t.nodes[id].typ }
func (t *tree) MessageID(id NodeID) int32           { return t.nodes[id].messageID }
func (t *tree) Message(id NodeID) string            { return t.strs[t.MessageID(id)] }
func (t *tree) NameID(id NodeID) int32              { return t.nodes[id].nameID }
func (t *tree) Name(id NodeID) string               { return t.strs[t.NameID(id)] }
func (t *tree) IsType(id NodeID, typ NodeType) bool { return t.Type(id) == typ }
func (t *tree) IsNamed(id NodeID, nameID int32) bool {
	return t.Type(id) == NodeType_Node && t.NameID(id) == nameID
}
func (t *tree) Location(cursor int) Location {
	t.ensurePosView()
	return t.posView.LocationAt(cursor)
}
func (t *tree) Span(id NodeID) Span {
	t.ensurePosView()
	n := &t.nodes[id]
	return Span{
		Start: t.posView.LocationAt(n.start),
		End:   t.posView.LocationAt(n.end),
	}
}
func (t *tree) CursorU16(cursor int) int {
	t.ensurePosView()
	return t.posView.CursorU16(cursor)
}
func (t *tree) ensurePosView() {
	if t.posView == nil {
		t.posView = newPosIndex(t.input)
	}
}
func (t *tree) Children(id NodeID) []NodeID {
	n := &t.nodes[id]
	if n.childID == -1 {
		return nil
	}
	if n.typ == NodeType_Node || n.typ == NodeType_Error {
		return []NodeID{NodeID(n.childID)}
	}
	if n.typ == NodeType_Sequence {
		cr := t.childRanges[n.childID]
		return t.children[cr.start:cr.end]
	}
	return nil
}
func (t *tree) Child(id NodeID) (NodeID, bool) {
	childID := t.nodes[id].childID
	if childID == -1 {
		return 0, false
	}
	return NodeID(childID), true
}
func (t *tree) Copy() Tree {

	if t == nil {
		return nil
	}

	var (
		nodes       = make([]node, len(t.nodes))
		children    = make([]NodeID, len(t.children))
		childRanges = make([]struct{ start, end int32 }, len(t.childRanges))
	)
	copy(nodes, t.nodes)
	copy(children, t.children)
	copy(childRanges, t.childRanges)

	return &tree{
		nodes:       nodes,
		children:    children,
		childRanges: childRanges,
		strs:        t.strs,
		input:       t.input,
		root:        t.root,
	}
}
func (t *tree) AddString(start, end int) NodeID {
	id := NodeID(len(t.nodes))
	t.nodes = append(t.nodes, node{
		typ:       NodeType_String,
		start:     start,
		end:       end,
		nameID:    -1,
		childID:   -1,
		messageID: -1,
	})
	return id
}
func (t *tree) AddSequence(children []NodeID, start, end int) NodeID {
	id := NodeID(len(t.nodes))
	childRangeID := int32(-1)
	if len(children) > 0 {
		childRangeID = int32(len(t.childRanges))
		childStart := int32(len(t.children))
		t.children = append(t.children, children...)
		childEnd := int32(len(t.children))
		t.childRanges = append(t.childRanges, struct{ start, end int32 }{childStart, childEnd})
	}
	t.nodes = append(t.nodes, node{
		typ:       NodeType_Sequence,
		start:     start,
		end:       end,
		childID:   childRangeID,
		nameID:    -1,
		messageID: -1,
	})
	return id
}
func (t *tree) AddNode(nameID int32, child NodeID, start, end int) NodeID {
	id := NodeID(len(t.nodes))
	t.nodes = append(t.nodes, node{
		typ:       NodeType_Node,
		start:     start,
		end:       end,
		nameID:    nameID,
		childID:   int32(child),
		messageID: -1,
	})
	return id
}
func (t *tree) AddNamedString(nameID int32, start, end int) NodeID {
	stringID := NodeID(len(t.nodes))
	t.nodes = append(t.nodes, node{
		typ:       NodeType_String,
		start:     start,
		end:       end,
		nameID:    -1,
		childID:   -1,
		messageID: -1,
	}, node{
		typ:       NodeType_Node,
		start:     start,
		end:       end,
		nameID:    nameID,
		childID:   int32(stringID),
		messageID: -1,
	})
	return stringID + 1
}
func (t *tree) AddError(labelID, messageID int32, start, end int) NodeID {
	id := NodeID(len(t.nodes))
	t.nodes = append(t.nodes, node{
		typ:       NodeType_Error,
		start:     start,
		end:       end,
		nameID:    labelID,
		childID:   -1,
		messageID: messageID,
	})
	return id
}
func (t *tree) AddErrorWithChild(labelID, messageID int32, childID NodeID, start, end int) NodeID {
	id := NodeID(len(t.nodes))
	t.nodes = append(t.nodes, node{
		typ:       NodeType_Error,
		start:     start,
		end:       end,
		nameID:    labelID,
		childID:   int32(childID),
		messageID: messageID,
	})
	return id
}
func (t *tree) Visit(id NodeID, fn func(NodeID) bool) {
	if !fn(id) {
		return
	}
	switch t.nodes[id].typ {
	case NodeType_Sequence:
		for _, child := range t.Children(id) {
			t.Visit(child, fn)
		}
	case NodeType_Node, NodeType_Error:
		if child, ok := t.Child(id); ok {
			t.Visit(child, fn)
		}
	}
}
func (t *tree) Text(id NodeID) string {
	n := &t.nodes[id]

	switch n.typ {
	case NodeType_String:
		return string(t.input[n.start:n.end])

	case NodeType_Sequence:
		var b strings.Builder
		for _, childID := range t.Children(id) {
			b.WriteString(t.Text(childID))
		}
		return b.String()

	case NodeType_Node:
		if child, ok := t.Child(id); ok {
			return t.Text(child)
		}
		return ""

	case NodeType_Error:
		if child, ok := t.Child(id); ok {
			return t.Text(child)
		}
		return fmt.Sprintf("error[%s]", t.Name(id))
	default:
		panic(fmt.Sprintf("Unknown node type: %T", n.typ))
	}
}
func (t *tree) Pretty(id NodeID) string {
	vi := newPrettyPrinter(t, t.input, func(input string, _ FormatToken) string {
		return input
	})
	vi.visit(id)
	return vi.output.String()
}
func (t *tree) Highlight(id NodeID) string {
	vi := newPrettyPrinter(t, t.input, func(input string, token FormatToken) string {
		return treePrinterTheme[token] + input + treePrinterTheme[FormatToken_None]
	})
	vi.visit(id)
	return vi.output.String()
}

var treePrinterTheme = map[FormatToken]string{
	FormatToken_None:    "\033[0m",
	FormatToken_Range:   "\033[1;31;5;228m",
	FormatToken_Literal: "\033[1;38;5;245m",
	FormatToken_Error:   "\033[1;38;5;127m",
}

type prettyPrinter struct {
	input []byte
	tree  *tree
	*treePrinter[FormatToken]
}

func newPrettyPrinter(tree *tree, input []byte, format FormatFunc[FormatToken]) *prettyPrinter {
	return &prettyPrinter{
		tree:        tree,
		input:       input,
		treePrinter: newTreePrinter(format),
	}
}
func (vi *prettyPrinter) visit(id NodeID) {
	n := &vi.tree.nodes[id]
	s := vi.tree.Span(id)

	switch n.typ {
	case NodeType_String:
		text := string(vi.input[n.start:n.end])
		escaped := strconv.Quote(text)
		vi.write(vi.format(escaped, FormatToken_Literal))
		vi.write(vi.format(fmt.Sprintf(" (%s)", s.String()), FormatToken_Range))

	case NodeType_Sequence:
		children := vi.tree.Children(id)
		seq := fmt.Sprintf("Sequence<%d> (%s)", len(children), s.String())
		vi.writel(vi.format(seq, FormatToken_Range))
		for i, child := range children {
			switch {
			case i == len(children)-1:
				vi.pwrite("└── ")
				vi.indent("    ")
				vi.visit(child)
				vi.unindent()
			default:
				vi.pwrite("├── ")
				vi.indent("│   ")
				vi.visit(child)
				vi.unindent()
				vi.write("\n")
			}
		}

	case NodeType_Node:
		name := vi.tree.Name(id)
		rgst := fmt.Sprintf(" (%s)", s.String())
		vi.write(vi.format(name, FormatToken_Literal))
		vi.writel(vi.format(rgst, FormatToken_Range))
		vi.pwrite("└── ")
		vi.indent("    ")
		if child, ok := vi.tree.Child(id); ok {
			vi.visit(child)
		}
		vi.unindent()

	case NodeType_Error:
		label := vi.tree.Name(id)
		vi.write(vi.format(fmt.Sprintf("Error<%s>", label), FormatToken_Error))
		vi.write(vi.format(fmt.Sprintf(" (%s)", s.String()), FormatToken_Range))

		if child, ok := vi.tree.Child(id); ok {
			vi.writel("")
			vi.pwrite("└── ")
			vi.indent("    ")
			vi.visit(child)
			vi.unindent()
		}
	}
}

type FormatFunc[T any] func(input string, token T) string
type treePrinter[T any] struct {
	padStr *[]string
	output *strings.Builder
	format FormatFunc[T]
}

func newTreePrinter[T any](format FormatFunc[T]) *treePrinter[T] {
	return &treePrinter[T]{
		padStr: &[]string{},
		output: &strings.Builder{},
		format: format,
	}
}
func (tp *treePrinter[T]) indent(s string) {
	*tp.padStr = append(*tp.padStr, s)
}
func (tp *treePrinter[T]) unindent() {
	index := len(*tp.padStr) - 1
	*tp.padStr = (*tp.padStr)[:index]
}
func (tp *treePrinter[T]) padding() {
	for _, item := range *tp.padStr {
		tp.write(item)
	}
}
func (tp *treePrinter[T]) writel(s string) {
	tp.write(s)
	tp.output.WriteRune('\n')
}
func (tp *treePrinter[T]) pwritel(s string) {
	tp.pwrite(s)
	tp.output.WriteRune('\n')
}
func (tp *treePrinter[T]) write(s string) {
	tp.output.WriteString(s)
}
func (tp *treePrinter[T]) pwrite(s string) {
	tp.padding()
	tp.write(s)
}

var literalSanitizer = strings.NewReplacer(
	`"`, `\"`,
	`\`, `\\`,
	string('\n'), `\n`,
	string('\r'), `\r`,
	string('\t'), `\t`,
)

func escapeLiteral(s string) string {
	return literalSanitizer.Replace(s)
}

type FileLoadError struct {
	Path string
	Err  error
}

func (e *FileLoadError) Error() string {
	return fmt.Sprintf("failed to load grammar file %s: %v", e.Path, e.Err)
}
func (e *FileLoadError) Unwrap() error {
	return e.Err
}

type ParsingError struct {
	Message    string
	Label      string
	Start, End int
	Expected   []ErrHint
	FFPPC      int
}
type ErrHintType uint8

const (
	ErrHintType_Unknown ErrHintType = iota
	ErrHintType_EOF
	ErrHintType_Char
	ErrHintType_Range
)

type ErrHint struct {
	Type  ErrHintType
	Char  rune
	Range [2]rune
}

func (eh *ErrHint) eq(oh *ErrHint) bool {
	if eh.Type != oh.Type {
		return false
	}
	switch eh.Type {
	case ErrHintType_Char:
		return eh.Char == oh.Char
	case ErrHintType_Range:
		return eh.Range[0] == oh.Range[0] && eh.Range[1] == oh.Range[1]
	case ErrHintType_EOF:
		return true
	}
	return false
}
func (eh ErrHint) String() string {
	switch eh.Type {
	case ErrHintType_EOF:
		return "end of input"
	case ErrHintType_Char:
		return formatChar(eh.Char)
	case ErrHintType_Range:
		return fmt.Sprintf("'%c'-'%c'", eh.Range[0], eh.Range[1])
	default:
		return "?"
	}
}
func formatChar(c rune) string {
	switch {
	case c == 0:
		return "end of input"
	case c == '\n':
		return "newline"
	case c == '\r':
		return "carriage return"
	case c == '\t':
		return "tab"
	case c == ' ':
		return "space"
	case c < 32 || c == 127:

		return fmt.Sprintf("'\\x%02x'", c)
	default:
		return fmt.Sprintf("'%c'", c)
	}
}
func FormatExpectedMessage(hints []ErrHint, input []byte, pos int) string {
	if len(hints) == 0 {
		return ""
	}
	parts := make([]string, len(hints))
	for i, h := range hints {
		parts[i] = h.String()
	}
	got := "end of input"
	if pos < len(input) {
		got = fmt.Sprintf("'%c'", input[pos])
	}
	if len(parts) == 1 {
		return fmt.Sprintf("Expected %s but got %s", parts[0], got)
	}
	return fmt.Sprintf("Expected %s but got %s",
		joinWithOr(parts), got)
}
func joinWithOr(items []string) string {
	if len(items) == 0 {
		return ""
	}
	if len(items) == 1 {
		return items[0]
	}
	if len(items) == 2 {
		return items[0] + " or " + items[1]
	}

	result := ""
	for i, item := range items {
		if i == len(items)-1 {
			result += "or " + item
		} else {
			result += item + ", "
		}
	}
	return result
}
func (e ParsingError) Error() string {
	message := e.Label
	if e.Message != "" {
		message = e.Message
	}

	span := fmt.Sprintf("%d", e.Start+1)
	if e.Start != e.End {
		span += fmt.Sprintf("..%d", e.End+1)
	}
	return fmt.Sprintf("%s @ %s", message, span)
}
func isthrown(err error) bool {
	_, ok := err.(ParsingError)
	return ok
}
func (s DiagnosticSeverity) String() string {
	switch s {
	case DiagnosticError:
		return "error"
	case DiagnosticWarning:
		return "warning"
	case DiagnosticInfo:
		return "info"
	case DiagnosticHint:
		return "hint"
	default:
		return "unknown"
	}
}
func (d Diagnostic) String() string {
	return fmt.Sprintf("[%s] %s: %s", d.Severity, d.Code, d.Message)
}
func (d Diagnostic) FormatCLI() string {
	loc := d.Location.Span.Start
	return fmt.Sprintf(
		"%s:%d:%d: %s: %s [%s]",
		d.FilePath,
		loc.Line,
		loc.Column,
		d.Severity,
		d.Message,
		d.Code,
	)
}

type frameType int8

const (
	frameType_Backtracking frameType = iota
	frameType_Call
	frameType_Capture
)

type frame struct {
	cursor int

	pc uint32

	capId uint32

	nodesStart uint32
	nodesEnd   uint32

	t frameType

	predicate bool
}
type stack struct {
	frames    []frame
	nodeArena []NodeID
	nodes     []NodeID
	tree      *tree
}

func (s *stack) push(f frame) {
	f.nodesStart = uint32(len(s.nodeArena))
	f.nodesEnd = f.nodesStart
	s.frames = append(s.frames, f)
}
func (s *stack) pop() frame {
	idx := len(s.frames) - 1
	f := s.frames[idx]
	s.frames = s.frames[:idx]
	return f
}
func (s *stack) top() *frame {
	return &s.frames[len(s.frames)-1]
}
func (s *stack) len() int {
	return len(s.frames)
}
func (s *stack) frameNodes(f *frame) []NodeID {
	return s.nodeArena[f.nodesStart:f.nodesEnd]
}
func (s *stack) capture(nodes ...NodeID) {
	if len(nodes) == 0 {
		return
	}
	n := len(s.frames)
	if n > 0 {

		s.nodeArena = append(s.nodeArena, nodes...)
		s.frames[n-1].nodesEnd = uint32(len(s.nodeArena))
		return
	}
	s.nodes = append(s.nodes, nodes...)
}
func (s *stack) popAndCapture() frame {
	idx := len(s.frames) - 1
	f := s.frames[idx]
	s.frames = s.frames[:idx]

	if f.nodesStart != f.nodesEnd {
		if idx > 0 {

			s.frames[idx-1].nodesEnd = f.nodesEnd
		} else {

			s.nodes = append(s.nodes, s.nodeArena[f.nodesStart:f.nodesEnd]...)
		}
	}
	return f
}
func (s *stack) collectCaptures() {
	n := len(s.frames)
	if n == 0 {
		return
	}
	f := &s.frames[n-1]
	if f.nodesEnd > f.nodesStart {
		if n == 1 {
			s.nodes = append(s.nodes, s.nodeArena[f.nodesStart:f.nodesEnd]...)
		} else {

			s.frames[n-2].nodesEnd = f.nodesEnd
		}
	}
}
func (s *stack) truncateArena(pos uint32) {
	s.nodeArena = s.nodeArena[:pos]
}
func (s *stack) reset() {
	s.frames = s.frames[:0]
	s.nodeArena = s.nodeArena[:0]
	s.nodes = s.nodes[:0]
}

type charset struct {
	bits [32]byte
}

func newCharSet() *charset { return &charset{} }
func newCharsetForRune(r rune) *charset {
	cs := newCharSet()
	cs.add(r)
	return cs
}
func newCharsetForRange(a, b rune) *charset {
	cs := newCharSet()
	cs.addRange(a, b)
	return cs
}
func fitcs(r rune) bool { return int(r) < 0x80 && int(r)>>7 != 1 }
func (cs *charset) complement() *charset {
	newCs := charset{}
	for i, item := range cs.bits {
		newCs.bits[i] = ^item
	}
	return &newCs
}
func (cs *charset) begin() int         { return 0 }
func (cs *charset) end() int           { return 256 }
func (cs *charset) eq(o *charset) bool { return cs.encoded() == o.encoded() }
func (cs *charset) encoded() string    { return hex.EncodeToString(cs.bits[:]) }
func (cs *charset) add(r rune) {
	if !fitcs(r) {
		panic(fmt.Sprintf("code point `U+%X` (%c) is out of bounds", r, r))
	}
	i := int(r)
	cs.bits[i>>3] |= 1 << (i & 7)
}
func (cs *charset) addRange(start, end rune) {
	if !fitcs(start) || !fitcs(end) || start > end {
		panic(fmt.Sprintf("range out of charset bounds: `%c-%c`", start, end))
	}
	for r := start; r <= end; r++ {
		cs.add(r)
	}
}
func (cs *charset) hasByte(i byte) bool {

	return cs.bits[i>>3]&(1<<(i&7)) != 0
}
func (cs *charset) popcount() int {
	var total int
	for _, oneByte := range cs.bits {
		total += bits.OnesCount16(uint16(oneByte))
	}
	return total
}
func charsetMerge(a, b *charset) *charset {
	out := newCharSet()
	for i := 0; i < 32; i++ {
		out.bits[i] = a.bits[i] | b.bits[i]
	}
	return out
}
func (cs *charset) precomputeExpectedSet() []expected {
	var (
		ex []expected
		rg bool
		st int
		pr int = -2
	)

	if cs.popcount() > 100 {
		return ex
	}
	for r := cs.begin(); r < cs.end(); r++ {
		has := cs.hasByte(byte(r))
		if has {
			if !rg {
				rg = true
				st = r
			}
			pr = r
		} else if rg {
			rg = false
			addRangeToSlice(&ex, rune(st), rune(pr))
		}
	}
	if rg {
		addRangeToSlice(&ex, rune(st), rune(pr))
	}

	return ex
}
func addRangeToSlice(ex *[]expected, start, end rune) {
	if start == end {
		*ex = append(*ex, expected{a: start})
	} else if end == start+1 {
		*ex = append(*ex, expected{a: start})
		*ex = append(*ex, expected{a: end})
	} else {
		*ex = append(*ex, expected{a: start, b: end})
	}
}
func (cs *charset) String() string {
	var (
		s  strings.Builder
		rg bool
		st int
		pr int = -2
	)
	s.WriteString("[")

	for r := cs.begin(); r < cs.end(); r++ {
		has := cs.hasByte(byte(r))
		if has {
			if !rg {
				rg = true
				st = r
			}
			pr = r
		} else if rg {
			rg = false
			addRangeToStr(&s, rune(st), rune(pr))
		}
	}
	if rg {
		addRangeToStr(&s, rune(st), rune(pr))
	}

	s.WriteString("]")
	return s.String()
}
func addRangeToStr(s *strings.Builder, start, end rune) {
	if start == end {
		s.WriteString(escapeLiteral(string(start)))
	} else if end == start+1 {
		s.WriteString(escapeLiteral(string(start)))
		s.WriteString(escapeLiteral(string(end)))
	} else {
		s.WriteString(escapeLiteral(string(start)))
		s.WriteString("..")
		s.WriteString(escapeLiteral(string(end)))
	}
}

type Bytecode struct {
	code []byte
	strs []string
	sets []charset
	sexp [][]expected
	smap map[string]int
	rxps map[int]int
	rxbs bitset512
	srcm *SourceMap
}

func (b *Bytecode) CompileErrorLabels(labels map[string]string) map[int]int {
	if len(labels) == 0 {
		return nil
	}
	result := make(map[int]int, len(labels))
	for label, message := range labels {
		labelID, ok := b.smap[label]
		if !ok {
			continue
		}
		messageID, ok := b.smap[message]
		if !ok {
			messageID = len(b.strs)
			b.strs = append(b.strs, message)
			b.smap[message] = messageID
		}
		result[labelID] = messageID
	}
	return result
}

type bitset512 [8]uint64

func (b *bitset512) Set(id int)      { b[id>>6] |= 1 << (id & 63) }
func (b *bitset512) Has(id int) bool { return b[id>>6]&(1<<(id&63)) != 0 }

type expected struct {
	a, b rune
}

const expectedLimit = 20

type expectedInfo struct {
	cur int
	arr [expectedLimit]expected
}

func (e *expectedInfo) add(s expected) {
	if e.cur == expectedLimit {
		return
	}
	if s.b == 0 {
		switch s.a {
		case 0, ' ', '\n', '\r', '\t':
			return
		}
	}
	for i := 0; i < e.cur; i++ {
		if e.arr[i] == s {
			return
		}
	}
	e.arr[e.cur] = s
	e.cur++
}
func (e *expectedInfo) clear() {
	e.cur = 0
}

type virtualMachine struct {
	ffp            int
	ffpPC          int
	stack          *stack
	bytecode       *Bytecode
	predicate      bool
	expected       *expectedInfo
	showFails      bool
	errLabels      map[int]int
	capOffsetId    int
	capOffsetStart int
}

const (
	opHalt byte = iota
	opAny
	opChar
	opRange
	opFail
	opFailTwice
	opChoice
	opChoicePred
	opCapCommit
	opCapPartialCommit
	opCapBackCommit
	opCall
	opCapReturn
	opJump
	opThrow
	opCapBegin
	opCapEnd
	opSet
	opSpan
	opCapTerm
	opCapNonTerm
	opCommit
	opBackCommit
	opPartialCommit
	opReturn
	opCapTermBeginOffset
	opCapNonTermBeginOffset
	opCapEndOffset
	opChar32
	opRange32
)

var opNames = map[byte]string{
	opHalt:                  "halt",
	opAny:                   "any",
	opChar:                  "char",
	opChar32:                "char32",
	opRange:                 "range",
	opRange32:               "range32",
	opSet:                   "set",
	opSpan:                  "span",
	opFail:                  "fail",
	opFailTwice:             "fail_twice",
	opChoice:                "choice",
	opChoicePred:            "choice_pred",
	opCommit:                "commit",
	opPartialCommit:         "partial_commit",
	opBackCommit:            "back_commit",
	opCapCommit:             "cap_commit",
	opCapBackCommit:         "cap_back_commit",
	opCapPartialCommit:      "cap_partial_commit",
	opCapReturn:             "cap_return",
	opCall:                  "call",
	opReturn:                "return",
	opJump:                  "jump",
	opThrow:                 "throw",
	opCapBegin:              "cap_begin",
	opCapEnd:                "cap_end",
	opCapTerm:               "cap_term",
	opCapNonTerm:            "cap_non_term",
	opCapTermBeginOffset:    "cap_term_begin_offset",
	opCapNonTermBeginOffset: "cap_non_term_begin_offset",
	opCapEndOffset:          "cap_end_offset",
}
var (
	opAnySizeInBytes = 1

	opCharSizeInBytes = 3

	opChar32SizeInBytes = 5

	opRangeSizeInBytes = 5

	opRange32SizeInBytes = 9

	opSetSizeInBytes  = 3
	opSpanSizeInBytes = 3

	opChoiceSizeInBytes = 3
	opCommitSizeInBytes = 3
	opFailSizeInBytes   = 1

	opCallSizeInBytes = 4

	opReturnSizeInBytes                = 1
	opJumpSizeInBytes                  = 3
	opThrowSizeInBytes                 = 3
	opHaltSizeInBytes                  = 1
	opCapBeginSizeInBytes              = 3
	opCapEndSizeInBytes                = 1
	opCapTermSizeInBytes               = 3
	opCapNonTermSizeInBytes            = 5
	opCapTermBeginOffsetSizeInBytes    = 1
	opCapNonTermBeginOffsetSizeInBytes = 3
	opCapEndOffsetSizeInBytes          = 1
)

func NewVirtualMachine(bytecode *Bytecode) *virtualMachine {
	tr := &tree{
		nodes:       make([]node, 0, 256),
		children:    make([]NodeID, 0, 512),
		childRanges: make([]struct{ start, end int32 }, 0, 256),
	}
	stk := &stack{
		frames:    make([]frame, 0, 256),
		nodes:     make([]NodeID, 0, 256),
		nodeArena: make([]NodeID, 0, 256),
		tree:      tr,
	}
	stk.tree.bindStrings(bytecode.strs)
	vm := &virtualMachine{stack: stk, bytecode: bytecode, ffp: -1}
	return vm
}
func (vm *virtualMachine) SetShowFails(showFails bool) {
	if showFails {
		vm.expected = &expectedInfo{}
		vm.showFails = true
		return
	}
	vm.showFails = false
}
func (vm *virtualMachine) SetLabelMessages(labels map[int]int) {
	vm.errLabels = labels
}
func (vm *virtualMachine) SourceMap() *SourceMap {
	return vm.bytecode.srcm
}
func (vm *virtualMachine) Match(data []byte) (Tree, int, error) {
	return vm.MatchRule(data, 0)
}
func (vm *virtualMachine) MatchRule(data []byte, ruleAddress int) (Tree, int, error) {

	vm.reset()

	vm.stack.tree.bindInput(data)

	stack := vm.stack
	code := vm.bytecode.code
	sets := vm.bytecode.sets
	ilen := len(data)
	cursor := 0
	pc := 0

	if ruleAddress > 0 {
		stack.push(vm.mkCallFrame(opCallSizeInBytes))
		pc = ruleAddress
	}
code:
	for {
		op := code[pc]

		switch op {
		case opHalt:

			if len(stack.nodes) > 0 {
				idx := len(stack.nodes) - 1
				nid := stack.nodes[idx]
				stack.tree.SetRoot(nid)
			}
			return stack.tree, cursor, nil

		case opAny:
			if cursor >= ilen {
				goto fail
			}
			_, s := decodeRune(data, cursor)
			cursor += s
			pc += opAnySizeInBytes

		case opChar:
			e := rune(decodeU16(code, pc+1))
			if cursor >= ilen {
				goto fail
			}
			c, s := decodeRune(data, cursor)
			if c != e {
				if vm.showFails {
					vm.updateExpected(cursor, expected{a: e})
				}
				goto fail
			}
			cursor += s
			pc += opCharSizeInBytes

		case opChar32:
			e := rune(decodeU32(code, pc+1))
			if cursor >= ilen {
				goto fail
			}
			c, s := decodeRune(data, cursor)
			if c != e {
				if vm.showFails {
					vm.updateExpected(cursor, expected{a: e})
				}
				goto fail
			}
			cursor += s
			pc += opChar32SizeInBytes

		case opRange:
			if cursor >= ilen {
				goto fail
			}
			c, s := decodeRune(data, cursor)
			a := rune(decodeU16(code, pc+1))
			b := rune(decodeU16(code, pc+3))
			if c < a || c > b {
				if vm.showFails {
					vm.updateExpected(cursor, expected{a: a, b: b})
				}
				goto fail
			}
			cursor += s
			pc += opRangeSizeInBytes

		case opRange32:
			if cursor >= ilen {
				goto fail
			}
			c, s := decodeRune(data, cursor)
			a := rune(decodeU32(code, pc+1))
			b := rune(decodeU32(code, pc+5))
			if c < a || c > b {
				if vm.showFails {
					vm.updateExpected(cursor, expected{a: a, b: b})
				}
				goto fail
			}
			cursor += s
			pc += opRange32SizeInBytes

		case opSet:
			if cursor >= ilen {
				goto fail
			}
			c := data[cursor]
			i := decodeU16(code, pc+1)
			if !sets[i].hasByte(c) {
				if vm.showFails {
					vm.updateSetExpected(cursor, i)
				}
				goto fail
			}
			cursor++
			pc += opSetSizeInBytes

		case opSpan:
			sid := decodeU16(code, pc+1)
			set := sets[sid]
			for cursor < ilen {
				c := data[cursor]
				if set.hasByte(c) {
					cursor++
					continue
				}
				break
			}
			pc += opSetSizeInBytes

		case opFail:
			goto fail

		case opFailTwice:
			stack.pop()
			goto fail

		case opChoice:
			lb := int(decodeU16(code, pc+1))
			stack.push(mkBacktrackFrame(lb, cursor))
			pc += opChoiceSizeInBytes

		case opChoicePred:
			lb := int(decodeU16(code, pc+1))
			stack.push(mkBacktrackPredFrame(lb, cursor))
			pc += opChoiceSizeInBytes
			vm.predicate = true

		case opCommit:
			stack.pop()
			pc = int(decodeU16(code, pc+1))

		case opBackCommit:
			cursor = stack.pop().cursor
			pc = int(decodeU16(code, pc+1))

		case opPartialCommit:
			pc = int(decodeU16(code, pc+1))
			stack.top().cursor = cursor

		case opCall:
			stack.push(vm.mkCallFrame(pc + opCallSizeInBytes))
			pc = int(decodeU16(code, pc+1))

		case opReturn:
			f := stack.pop()
			pc = int(f.pc)

		case opJump:
			pc = int(decodeU16(code, pc+1))

		case opThrow:
			if vm.predicate {
				pc += opThrowSizeInBytes
				goto fail
			}
			lb := int(decodeU16(code, pc+1))
			if addr, ok := vm.bytecode.rxps[lb]; ok {
				stack.push(vm.mkCallFrame(pc + opThrowSizeInBytes))
				pc = addr
				continue
			}
			return nil, cursor, vm.mkErr(data, lb, cursor, vm.ffp)

		case opCapBegin:
			id := int(decodeU16(code, pc+1))
			stack.push(vm.mkCaptureFrame(id, cursor))
			pc += opCapBeginSizeInBytes

		case opCapEnd:
			f := stack.pop()
			nodes := stack.frameNodes(&f)
			stack.truncateArena(f.nodesStart)
			vm.newNode(cursor, f, nodes)
			pc += opCapEndSizeInBytes

		case opCapTerm:
			vm.newTermNode(cursor, int(decodeU16(code, pc+1)))
			pc += opCapTermSizeInBytes

		case opCapNonTerm:
			id := int(decodeU16(code, pc+1))
			offset := int(decodeU16(code, pc+3))
			vm.newNonTermNode(id, cursor, offset)
			pc += opCapNonTermSizeInBytes

		case opCapTermBeginOffset:
			vm.capOffsetId = -1
			vm.capOffsetStart = cursor
			pc += opCapTermBeginOffsetSizeInBytes

		case opCapNonTermBeginOffset:
			vm.capOffsetId = int(decodeU16(code, pc+1))
			vm.capOffsetStart = cursor
			pc += opCapNonTermBeginOffsetSizeInBytes

		case opCapEndOffset:
			offset := cursor - vm.capOffsetStart
			pc += opCapEndOffsetSizeInBytes
			if vm.capOffsetId < 0 {
				vm.newTermNode(cursor, offset)
				continue
			}
			vm.newNonTermNode(vm.capOffsetId, cursor, offset)

		case opCapCommit:
			stack.popAndCapture()
			pc = int(decodeU16(code, pc+1))

		case opCapBackCommit:
			f := stack.popAndCapture()
			cursor = f.cursor
			pc = int(decodeU16(code, pc+1))

		case opCapPartialCommit:
			pc = int(decodeU16(code, pc+1))
			top := stack.top()
			top.cursor = cursor
			stack.collectCaptures()

			top.nodesStart = uint32(len(stack.nodeArena))
			top.nodesEnd = top.nodesStart

		case opCapReturn:
			f := stack.popAndCapture()
			pc = int(f.pc)

		default:
			panic("NO ENTIENDO SENOR")
		}
	}

fail:
	if cursor > vm.ffp {
		vm.ffp = cursor
		vm.ffpPC = pc
	}

	for stack.len() > 0 {
		f := stack.pop()

		stack.truncateArena(f.nodesStart)

		if f.t == frameType_Backtracking {
			pc = int(f.pc)
			vm.predicate = f.predicate
			cursor = f.cursor

			goto code
		}
	}

	if len(stack.nodes) > 0 {
		idx := len(stack.nodes) - 1
		nid := stack.nodes[idx]
		stack.tree.SetRoot(nid)
	}
	return stack.tree, cursor, vm.mkErr(data, 0, cursor, vm.ffp)
}
func (vm *virtualMachine) reset() {
	vm.stack.reset()
	vm.stack.tree.reset()
	vm.ffp = -1
	vm.ffpPC = 0

	if vm.showFails {
		vm.expected.clear()
	}
}
func mkBacktrackFrame(pc, cursor int) frame {
	return frame{
		t:      frameType_Backtracking,
		pc:     uint32(pc),
		cursor: cursor,
	}
}
func mkBacktrackPredFrame(pc, cursor int) frame {
	f := mkBacktrackFrame(pc, cursor)
	f.predicate = true
	return f
}
func (vm *virtualMachine) mkCaptureFrame(id, cursor int) frame {
	return frame{
		t:      frameType_Capture,
		capId:  uint32(id),
		cursor: cursor,
	}
}
func (vm *virtualMachine) mkCallFrame(pc int) frame {
	return frame{t: frameType_Call, pc: uint32(pc)}
}
func (vm *virtualMachine) newTermNode(cursor, offset int) {
	if offset > 0 {
		begin := cursor - offset
		nodeID := vm.stack.tree.AddString(begin, cursor)
		vm.stack.capture(nodeID)
	}
}
func (vm *virtualMachine) newNonTermNode(capId, cursor, offset int) {
	if offset > 0 {
		begin := cursor - offset
		named := vm.stack.tree.AddNamedString(int32(capId), begin, cursor)
		vm.stack.capture(named)
	}
}
func (vm *virtualMachine) newNode(cursor int, f frame, nodes []NodeID) {
	var (
		nodeID  NodeID
		hasNode = false
		isrxp   = vm.bytecode.rxbs.Has(int(f.capId))
		capId   = int32(f.capId)
		start   = f.cursor
		end     = cursor
	)
	switch len(nodes) {
	case 0:
		if cursor-f.cursor > 0 {
			nodeID = vm.stack.tree.AddString(start, end)
			hasNode = true
		} else if !isrxp {

			return
		}

	case 1:
		nodeID = nodes[0]
		hasNode = true
	default:
		nodeID = vm.stack.tree.AddSequence(nodes, start, end)
		hasNode = true
	}

	if isrxp {
		msgID, ok := vm.errLabels[int(f.capId)]
		if !ok {
			msgID = int(f.capId)
		}
		var errNode NodeID
		if hasNode {
			errNode = vm.stack.tree.AddErrorWithChild(capId, int32(msgID), nodeID, start, end)
		} else {
			errNode = vm.stack.tree.AddError(capId, int32(msgID), start, end)
		}
		vm.stack.capture(errNode)
		return
	}

	if !hasNode {
		return
	}

	if f.capId == 0 {
		vm.stack.capture(nodeID)
		return
	}

	named := vm.stack.tree.AddNode(capId, nodeID, start, end)
	vm.stack.capture(named)
}
func (vm *virtualMachine) updateExpected(cursor int, s expected) {
	shouldClear := cursor > vm.ffp
	shouldAdd := cursor >= vm.ffp

	if shouldClear {
		vm.expected.clear()
	}
	if shouldAdd {
		vm.expected.add(s)
	}
}
func (vm *virtualMachine) updateSetExpected(cursor int, sid uint16) {
	shouldClear := cursor > vm.ffp
	shouldAdd := cursor >= vm.ffp

	if shouldClear {
		vm.expected.clear()
	}
	if shouldAdd {
		for i, item := range vm.bytecode.sexp[sid] {
			vm.expected.add(item)
			if i > expectedLimit-1 {
				break
			}
		}
	}
}
func (vm *virtualMachine) mkErr(data []byte, errLabelID int, cursor, errCursor int) error {

	var (
		isEof   bool
		message strings.Builder
		c       rune
	)
	if cursor >= len(data) {
		isEof = true
	} else {
		c, _ = decodeRune(data, cursor)
	}
	if msgID, ok := vm.errLabels[errLabelID]; ok {

		message.WriteString(vm.bytecode.strs[msgID])
	} else {

		if errLabelID > 0 {
			errLabel := vm.bytecode.strs[errLabelID]
			message.WriteRune('[')
			message.WriteString(errLabel)
			message.WriteRune(']')
			message.WriteRune(' ')
		}

		if vm.showFails && vm.expected.cur > 0 {
			message.WriteString("Expected ")
			for i := 0; i < vm.expected.cur; i++ {
				e := vm.expected.arr[i]
				message.WriteRune('\'')
				message.WriteRune(e.a)
				if e.b != 0 {
					message.WriteRune('-')
					message.WriteRune(e.b)
				}
				message.WriteRune('\'')
				if i < vm.expected.cur-1 {
					message.WriteString(", ")
				}
			}
			message.WriteString(" but got ")
		} else {
			message.WriteString("Unexpected ")
		}
		if isEof {
			message.WriteString("EOF")
		} else {
			message.WriteRune('\'')
			message.WriteRune(c)
			message.WriteRune('\'')
		}
	}
	errLabel := ""
	if errLabelID > 0 {
		errLabel = vm.bytecode.strs[errLabelID]
	}
	var expected []ErrHint
	if vm.expected != nil && vm.expected.cur > 0 {
		expected = make([]ErrHint, vm.expected.cur)
		for i := 0; i < vm.expected.cur; i++ {
			ex := vm.expected.arr[i]
			switch {
			case ex.a == 0:
				expected[i] = ErrHint{Type: ErrHintType_EOF}
			case ex.a != 0 && ex.b == 0:
				expected[i] = ErrHint{
					Type: ErrHintType_Char,
					Char: ex.a,
				}
			case ex.a != 0 && ex.b != 0:
				expected[i] = ErrHint{
					Type:  ErrHintType_Range,
					Range: [2]rune{ex.a, ex.b},
				}
			default:
				expected[i] = ErrHint{Type: ErrHintType_Unknown}
			}
		}
	}
	return ParsingError{
		Message:  message.String(),
		Label:    errLabel,
		Start:    cursor,
		End:      errCursor,
		Expected: expected,
		FFPPC:    vm.ffpPC,
	}
}
func decodeU16(code []byte, offset int) uint16 {
	return uint16(code[offset]) | uint16(code[offset+1])<<8
}
func decodeU32(code []byte, offset int) uint32 {
	return uint32(code[offset]) |
		uint32(code[offset+1])<<8 |
		uint32(code[offset+2])<<16 |
		uint32(code[offset+3])<<24
}
func decodeRune(data []byte, offset int) (rune, int) {
	if r := data[offset]; r < utf8.RuneSelf {
		return rune(r), 1
	}
	return utf8.DecodeRune(data[offset:])
}
