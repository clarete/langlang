// Code generated by langlang (unknown commit hash), DO NOT EDIT.
// Source File: ../grammars/json.peg
package benchmarks

var bytecodeForNoCapParser = &Bytecode{
	code: []byte{
		11, 5, 0, 0, 0, 18, 0, 0, 6, 18, 0, 11, 39, 0, 0, 21, 21, 0, 14, 1, 0, 18, 0, 0, 6, 35, 0, 7, 32, 0, 1, 5, 21, 38, 0, 14, 2, 0, 24, 6, 49, 0, 11, 119, 1, 0, 21, 49, 1, 6, 59, 0, 11, 50, 1, 0, 21, 49, 1, 6, 164, 0, 18, 0, 0, 17, 1, 0, 6, 149, 0, 6, 83, 0, 17, 2, 0, 17, 3, 0, 21, 146, 0, 6, 143, 0, 17, 2, 0, 17, 4, 0, 6, 101, 0, 17, 5, 0, 21, 104, 0, 14, 12, 0, 6, 113, 0, 17, 5, 0, 21, 116, 0, 14, 13, 0, 6, 125, 0, 17, 5, 0, 21, 128, 0, 14, 14, 0, 6, 137, 0, 17, 5, 0, 21, 140, 0, 14, 15, 0, 21, 146, 0, 17, 6, 0, 23, 71, 0, 6, 158, 0, 17, 1, 0, 21, 161, 0, 14, 11, 0, 21, 49, 1, 6, 254, 0, 18, 0, 0, 6, 179, 0, 17, 7, 0, 21, 179, 0, 6, 188, 0, 17, 8, 0, 21, 194, 0, 17, 9, 0, 18, 10, 0, 6, 218, 0, 17, 11, 0, 6, 212, 0, 17, 10, 0, 18, 10, 0, 21, 215, 0, 14, 9, 0, 21, 218, 0, 6, 251, 0, 17, 12, 0, 6, 233, 0, 17, 13, 0, 21, 233, 0, 6, 245, 0, 17, 10, 0, 18, 10, 0, 21, 248, 0, 14, 10, 0, 21, 251, 0, 21, 49, 1, 6, 16, 1, 2, 116, 0, 2, 114, 0, 2, 117, 0, 2, 101, 0, 21, 49, 1, 6, 37, 1, 2, 102, 0, 2, 97, 0, 2, 108, 0, 2, 115, 0, 2, 101, 0, 21, 49, 1, 2, 110, 0, 2, 117, 0, 2, 108, 0, 2, 108, 0, 24, 18, 0, 0, 17, 14, 0, 18, 0, 0, 6, 103, 1, 18, 0, 0, 11, 39, 0, 0, 6, 100, 1, 18, 0, 0, 18, 0, 0, 17, 15, 0, 18, 0, 0, 6, 94, 1, 11, 39, 0, 0, 21, 97, 1, 14, 3, 0, 23, 72, 1, 21, 103, 1, 18, 0, 0, 6, 115, 1, 17, 16, 0, 21, 118, 1, 14, 4, 0, 24, 18, 0, 0, 17, 17, 0, 18, 0, 0, 6, 172, 1, 18, 0, 0, 11, 188, 1, 0, 6, 169, 1, 18, 0, 0, 18, 0, 0, 17, 15, 0, 18, 0, 0, 6, 163, 1, 11, 188, 1, 0, 21, 166, 1, 14, 5, 0, 23, 141, 1, 21, 172, 1, 18, 0, 0, 6, 184, 1, 17, 18, 0, 21, 187, 1, 14, 6, 0, 24, 18, 0, 0, 18, 0, 0, 17, 1, 0, 6, 22, 2, 6, 212, 1, 17, 2, 0, 17, 3, 0, 21, 19, 2, 6, 16, 2, 17, 2, 0, 17, 4, 0, 6, 230, 1, 17, 5, 0, 21, 233, 1, 14, 12, 0, 6, 242, 1, 17, 5, 0, 21, 245, 1, 14, 13, 0, 6, 254, 1, 17, 5, 0, 21, 1, 2, 14, 14, 0, 6, 10, 2, 17, 5, 0, 21, 13, 2, 14, 15, 0, 21, 19, 2, 17, 6, 0, 23, 200, 1, 6, 31, 2, 17, 1, 0, 21, 34, 2, 14, 11, 0, 18, 0, 0, 6, 46, 2, 17, 19, 0, 21, 49, 2, 14, 7, 0, 18, 0, 0, 6, 62, 2, 11, 39, 0, 0, 21, 65, 2, 14, 8, 0, 24, 6, 73, 2, 1, 23, 69, 2, 24, 18, 20, 0, 24, 18, 21, 0, 24, 18, 21, 0, 24, 24, 24, 24, 24, 24,
	},
	strs: []string{
		"", "jsonValue", "eof", "itemAfterComma", "arrayClose", "memberAfterComma", "objectClose", "memberColon", "memberValue", "fracDigits", "expDigits", "strClose", "chrH1", "chrH2", "chrH3", "chrH4", "JSON", "Spacing", "Value", "EOF", "Object", "Array", "String", "Char", "Escape", "Unicode", "Hex", "Number", "Int", "Frac", "Exp", "Member", "Space", "EOL",
	},
	rxps: map[int]int{
		1: 602, 2: 578, 3: 586, 4: 599, 5: 590, 6: 600, 7: 598, 8: 594, 11: 601,
	},
	rxbs: bitset512{
		2558, 0, 0, 0, 0, 0, 0, 0,
	},

	smap: map[string]int{
		"Array": 21, "Char": 23, "EOF": 19, "EOL": 33, "Escape": 24, "Exp": 30, "Frac": 29, "Hex": 26, "Int": 28, "JSON": 16, "Member": 31, "Number": 27, "Object": 20, "Space": 32, "Spacing": 17, "String": 22, "Unicode": 25, "Value": 18, "arrayClose": 4, "chrH1": 12, "chrH2": 13, "chrH3": 14, "chrH4": 15, "eof": 2, "expDigits": 10, "fracDigits": 9, "itemAfterComma": 3, "jsonValue": 1, "memberAfterComma": 5, "memberColon": 7, "memberValue": 8, "objectClose": 6, "strClose": 11,
	},
	sets: []charset{
		{bits: [32]byte{0, 38, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
		{bits: [32]byte{0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
		{bits: [32]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
		{bits: [32]byte{0, 0, 0, 0, 4, 128, 0, 0, 0, 0, 0, 16, 68, 64, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
		{bits: [32]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
		{bits: [32]byte{0, 0, 0, 0, 0, 0, 255, 3, 126, 0, 0, 0, 126, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
		{bits: [32]byte{255, 255, 255, 255, 251, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}},
		{bits: [32]byte{0, 0, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
		{bits: [32]byte{0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
		{bits: [32]byte{0, 0, 0, 0, 0, 0, 254, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
		{bits: [32]byte{0, 0, 0, 0, 0, 0, 255, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
		{bits: [32]byte{0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
		{bits: [32]byte{0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
		{bits: [32]byte{0, 0, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
		{bits: [32]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
		{bits: [32]byte{0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
		{bits: [32]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
		{bits: [32]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
		{bits: [32]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
		{bits: [32]byte{0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
		{bits: [32]byte{255, 255, 255, 255, 255, 239, 255, 255, 255, 255, 255, 223, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}},
		{bits: [32]byte{255, 255, 255, 255, 255, 239, 255, 255, 255, 255, 255, 255, 255, 255, 255, 223, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}},
	},
	sexp: [][]expected{
		{{a: '\t'}, {a: '\n'}, {a: '\r'}, {a: ' '}},
		{{a: '"'}},
		{{a: '\\'}},
		{{a: '"'}, {a: '/'}, {a: '\\'}, {a: 'b'}, {a: 'f'}, {a: 'n'}, {a: 'r'}, {a: 't'}},
		{{a: 'u'}},
		{{a: '0', b: '9'}, {a: 'A', b: 'F'}, {a: 'a', b: 'f'}},
		{},
		{{a: '-'}},
		{{a: '0'}},
		{{a: '1', b: '9'}},
		{{a: '0', b: '9'}},
		{{a: '.'}},
		{{a: 'E'}, {a: 'e'}},
		{{a: '+'}, {a: '-'}},
		{{a: '['}},
		{{a: ','}},
		{{a: ']'}},
		{{a: '{'}},
		{{a: '}'}},
		{{a: ':'}},
		{},
		{},
	},
}

type NoCapParser struct {
	input []byte
	vm    *virtualMachine
}

func NewNoCapParser() *NoCapParser {
	vm := NewVirtualMachine(bytecodeForNoCapParser)
	return &NoCapParser{vm: vm}
}
func (p *NoCapParser) ParseJSON() (Tree, error)             { return p.parseFn(5) }
func (p *NoCapParser) ParseValue() (Tree, error)            { return p.parseFn(39) }
func (p *NoCapParser) ParseArray() (Tree, error)            { return p.parseFn(306) }
func (p *NoCapParser) ParseObject() (Tree, error)           { return p.parseFn(375) }
func (p *NoCapParser) ParseMember() (Tree, error)           { return p.parseFn(444) }
func (p *NoCapParser) Parseeof() (Tree, error)              { return p.parseFn(578) }
func (p *NoCapParser) ParseitemAfterComma() (Tree, error)   { return p.parseFn(586) }
func (p *NoCapParser) ParsememberAfterComma() (Tree, error) { return p.parseFn(590) }
func (p *NoCapParser) ParsememberValue() (Tree, error)      { return p.parseFn(594) }
func (p *NoCapParser) ParsememberColon() (Tree, error)      { return p.parseFn(598) }
func (p *NoCapParser) ParsearrayClose() (Tree, error)       { return p.parseFn(599) }
func (p *NoCapParser) ParseobjectClose() (Tree, error)      { return p.parseFn(600) }
func (p *NoCapParser) ParsestrClose() (Tree, error)         { return p.parseFn(601) }
func (p *NoCapParser) ParsejsonValue() (Tree, error)        { return p.parseFn(602) }
func (p *NoCapParser) Parse() (Tree, error)                 { return p.parseFn(5) }
func (p *NoCapParser) SetInput(input []byte)                { p.input = input }
func (p *NoCapParser) GetInput() []byte                     { return p.input }
func (p *NoCapParser) SetLabelMessages(el map[int]int)      { p.vm.SetLabelMessages(el) }
func (p *NoCapParser) SetShowFails(v bool)                  { p.vm.SetShowFails(v) }

func (p *NoCapParser) parseFn(addr int) (Tree, error) {
	val, _, err := p.vm.MatchRule(p.input, addr)
	return val, err
}
