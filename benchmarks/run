#!/bin/bash

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LANGLANG_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
OUTPUT_ROOT="${SCRIPT_DIR}/output"

# External libraries to benchmark against
declare -a external_suites=(
    "encoding_json"
    "buger_jsonparser"
    "pigeon"
    "pointlander"
    "pointlander_stripped"
    "antlr"
    "treesitter"
)

# Langlang versions to compare (git tags, branches, or commit hashes)
declare -a langlang_versions=(
    # "go/v0.0.1"
    # "go/v0.0.2"
    # "go/v0.0.3"
    # "go/v0.0.4"
    # "go/v0.0.5"
    # "go/v0.0.6"
    # "go/v0.0.7"
    # "go/v0.0.8"
    # "go/v0.0.9"
    "go/v0.0.10"
    "go/v0.0.11"
)

# Langlang configurations to benchmark per version
declare -a langlang_configs=(
    "langlang"
    "langlang_nocap"
    "langlang_stripped"
    "langlang_stripped_nocap"
)

# Whether to also run profiling (separate from timing)
RUN_PROFILING=${RUN_PROFILING:-false}

# Number of benchmark iterations (more = better statistics, but slower)
BENCH_COUNT=${BENCH_COUNT:-15}

# Duration per benchmark iteration
BENCH_TIME=${BENCH_TIME:-2s}

# tree-sitter JSON grammar (C source needed for cgo)
TREESITTER_JSON_REPO="https://github.com/tree-sitter/tree-sitter-json"
TREESITTER_JSON_REF="${TREESITTER_JSON_REF:-v0.24.8}"

fetch_treesitter_grammar() {
    local target_dir="${1}/tree-sitter-json-grammar"
    if [ -d "$target_dir/src" ]; then
        return 0
    fi
    echo "Fetching tree-sitter-json grammar ($TREESITTER_JSON_REF)..."
    git clone --depth=1 --branch="$TREESITTER_JSON_REF" \
        "$TREESITTER_JSON_REPO" "$target_dir"
}

record_environment() {
    local output_path=$1
    mkdir -p "$output_path"
    {
        echo "Date: $(date -u +"%Y-%m-%dT%H:%M:%SZ")"
        echo "Hostname: $(hostname)"
        echo "Go version: $(go version)"
        echo "OS: $(uname -s) $(uname -r)"
        echo "Arch: $(uname -m)"
        if command -v sysctl &>/dev/null; then
            echo "CPU: $(sysctl -n machdep.cpu.brand_string 2>/dev/null || echo 'unknown')"
            echo "Cores: $(sysctl -n hw.ncpu 2>/dev/null || nproc 2>/dev/null || echo 'unknown')"
            echo "Memory: $(sysctl -n hw.memsize 2>/dev/null | awk '{printf "%.0f GB", $1/1024/1024/1024}' || echo 'unknown')"
        elif [ -f /proc/cpuinfo ]; then
            echo "CPU: $(grep 'model name' /proc/cpuinfo | head -1 | cut -d: -f2 | xargs)"
            echo "Cores: $(nproc)"
            echo "Memory: $(free -h | awk '/^Mem:/ {print $2}')"
        fi
        echo "Git commit: $(git rev-parse HEAD 2>/dev/null || echo 'unknown')"
        echo "BENCH_COUNT: $BENCH_COUNT"
        echo "BENCH_TIME: $BENCH_TIME"
        echo "RUN_PROFILING: $RUN_PROFILING"
    } > "${output_path}/environment.txt"
}

check_system_readiness() {
    local cpu_idle
    if command -v top &>/dev/null; then
        cpu_idle=$(top -l 1 -n 0 2>/dev/null | grep "CPU usage" | awk '{print $7}' | tr -d '%')
        if [ -n "$cpu_idle" ] && [ "${cpu_idle%.*}" -lt 80 ]; then
            echo "WARNING: System CPU idle is only ${cpu_idle}%. Consider closing other applications."
        fi
    fi
    if command -v pmset &>/dev/null; then
        local power_source=$(pmset -g batt | head -1)
        if [[ "$power_source" == *"Battery"* ]]; then
            echo "WARNING: Running on battery. Results may be affected by power throttling."
        fi
    fi
}

run_benchmark() {
    local suite=$1
    local output_path=$2
    local version=${3:-}

    mkdir -p "$output_path"
    echo "  Output: $output_path"

    # Pure timing run (no profiling overhead)
    # Benchmark names are: BenchmarkParsers/input=<size>/parser=<name>/version=<ver>
    CGO_ENABLED=1 LANGLANG_VERSION=$version go test ./. -run=^$ \
        -bench="BenchmarkParsers/.*/^parser=${suite}$/" \
        -benchmem \
        -benchtime="$BENCH_TIME" \
        -count="$BENCH_COUNT" \
        -timeout=30m \
        -shuffle=off \
        2>&1 | tee "${output_path}/bench.txt"

    # Separate profiling run (if enabled)
    if [ "$RUN_PROFILING" = true ]; then
        echo "  Running profiling pass..."
        CGO_ENABLED=1 LANGLANG_VERSION=$version go test ./. -run=^$ \
            -bench="BenchmarkParsers/.*/^parser=${suite}$/" \
            -benchmem \
            -benchtime="$BENCH_TIME" \
            -count=1 \
            -timeout=30m \
            -memprofile="${output_path}/mem.out" \
            -cpuprofile="${output_path}/cpu.out" \
            >/dev/null 2>&1
    fi
}

run_external_benchmarks() {
    echo "External library benchmarks"
    cd "$SCRIPT_DIR"

    fetch_treesitter_grammar "$SCRIPT_DIR/treesitter_json"
    record_environment "${OUTPUT_ROOT}/external"

    echo -n "Regenerating parsers... "
    go generate ./...
    if [ $? -eq 0 ]; then
        echo "OK"
    else
        echo "FAIL"
        return 1
    fi

    for suite in "${external_suites[@]}"; do
        echo "Benchmarking: $suite"
        run_benchmark "$suite" "${OUTPUT_ROOT}/external/${suite}"
    done
}

run_langlang_version() {
    local version=$1
    local worktree_path="/tmp/langlang-bench-$$-${version//\//-}"

    echo "Langlang @ $version"

    # Create worktree for this version
    echo "Creating worktree at $worktree_path..."
    cd "$LANGLANG_ROOT"
    git worktree add "$worktree_path" "$version" --detach 2>/dev/null
    if [ $? -ne 0 ]; then
        echo "Failed to create worktree for $version"
        return 1
    fi

    # If benchmarks folder doesn't exist in this version, copy current one
    if [ ! -d "$worktree_path/benchmarks" ]; then
        echo "Benchmarks folder not found in $version, copying current benchmarks..."
        cp -r "$SCRIPT_DIR" "$worktree_path/benchmarks"
        # Remove any existing output from the copy
        rm -rf "$worktree_path/benchmarks/output"
    fi

    cd "$worktree_path/benchmarks"

    fetch_treesitter_grammar "$worktree_path/benchmarks/treesitter_json"
    record_environment "${OUTPUT_ROOT}/langlang/${version}"

    echo -n "Regenerating parsers for $version... "
    go generate ./...
    if [ $? -eq 0 ]; then
        echo "OK"
    else
        echo "FAIL (this version may have incompatible APIs)"
        cleanup_worktree "$worktree_path"
        return 1
    fi

    # Run benchmarks for each langlang configuration
    # Replace / with - in version for benchmark names (/ is a sub-benchmark separator)
    local safe_version="${version//\//-}"
    for config in "${langlang_configs[@]}"; do
        echo "Benchmarking: $config @ $version"
        run_benchmark "$config" "${OUTPUT_ROOT}/langlang/${version}/${config}" "$safe_version"
    done

    # Cleanup
    cleanup_worktree "$worktree_path"
}

cleanup_worktree() {
    local worktree_path=$1
    echo "Cleaning up worktree $worktree_path..."
    cd "$LANGLANG_ROOT"
    git worktree remove "$worktree_path" --force 2>/dev/null
}

# Cleanup any leftover worktrees on exit
cleanup_all() {
    cd "$LANGLANG_ROOT"
    git worktree prune
}
trap cleanup_all EXIT

# --- Main execution ---

check_system_readiness

# Run external library benchmarks first
run_external_benchmarks

# Then run langlang version benchmarks sequentially
for version in "${langlang_versions[@]}"; do
    run_langlang_version "$version"
done

echo ""
echo "Benchmarks Complete"
echo ""
echo "Results saved to: $OUTPUT_ROOT"
echo "  - External libs: $OUTPUT_ROOT/external/"
echo "  - Langlang versions: $OUTPUT_ROOT/langlang/<version>/"
echo ""
echo "To compare results with benchstat:"
echo "  benchstat -row /input -col /parser,/version \$(find output -name bench.txt)"
echo ""
echo "To configuration options:"
echo "  BENCH_COUNT=5 ./run       # fewer iterations (faster, less accurate)"
echo "  BENCH_TIME=5s ./run       # longer per iteration"
echo "  RUN_PROFILING=true ./run  # also generates cpu and mem profiles"
