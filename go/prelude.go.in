package {{.PackageName}}

// This is an autogenerated file. Check your build system and find the
// grammar to edit instead of editing this file directly, unless
// you're fine with changes getting erased.

import (
	"fmt"

	"github.com/clarete/langlang/go"
)

type {{.ParserName}} struct {
	langlang.BaseParser
	captureSpaces  bool
	predicateLevel int
	printTraceback bool
	recoveryTable  map[string]langlang.ParserFn[langlang.Value]
}

func (p *{{.ParserName}}) SetCaptureSpaces(v bool) {
	p.captureSpaces = v
}

func (p *{{.ParserName}}) SetPrintTraceback(v bool) {
	p.printTraceback = v
}

func (p *{{.ParserName}}) parseAny() (langlang.Value, error) {
	start := p.Location()
	r, err := p.Any()
	if err != nil {
		var zero langlang.Value
		return zero, err
	}
	return langlang.NewString(string(r), langlang.NewSpan(start, p.Location())), nil
}

func (p *{{.ParserName}}) parseRange(left, right rune) (langlang.Value, error) {
	start := p.Location()
	r, err := p.ExpectRange(left, right)
	if err != nil {
		var zero langlang.Value
		return zero, err
	}
	return langlang.NewString(string(r), langlang.NewSpan(start, p.Location())), nil
}

func (p *{{.ParserName}}) parseLiteral(literal string) (langlang.Value, error) {
	start := p.Location()
	r, err := p.ExpectLiteral(literal)
	if err != nil {
		var zero langlang.Value
		return zero, err
	}
	return langlang.NewString(r, langlang.NewSpan(start, p.Location())), nil
}

func (p *{{.ParserName}}) parseSpacing() (langlang.Value, error) {
	start := p.Location()
	v, err := langlang.ZeroOrMore(p, func(p langlang.Parser) (rune, error) {
		return langlang.ChoiceRune(p, []rune{' ', '\t', '\r', '\n'})
	})
	if err != nil {
		return nil, err
	}
	if !p.captureSpaces {
		return nil, nil
	}
	r := string(v)
	if len(r) == 0 {
		return nil, nil
	}
	s := langlang.NewString(r, langlang.NewSpan(start, p.Location()))
	return langlang.NewNode("Spacing", s, langlang.NewSpan(start, p.Location())), nil
}

func (p *{{.ParserName}}) ParseEOF() (langlang.Value, error) {
	return (func(p langlang.Parser) (langlang.Value, error) {
		var (
			start = p.Location()
			items []langlang.Value
			item  langlang.Value
			err   error
		)
		item, err = langlang.Not(p, func(p langlang.Parser) (langlang.Value, error) {
			return p.(*{{.ParserName}}).parseAny()
		})
		if err != nil {
			return nil, err
		}
		if item != nil {
			items = append(items, item)
		}
		return p.(*{{.ParserName}}).wrapSeq(items, langlang.NewSpan(start, p.Location())), nil
	}(p))
}

func (p *{{.ParserName}}) wrapSeq(items []langlang.Value, span langlang.Span) langlang.Value {
	switch len(items) {
	case 0:
		return nil
	case 1:
		return items[0]
	default:
		return langlang.NewSequence(items, span)
	}
}
