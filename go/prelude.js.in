/** Source: {{.GrammarPath}}
 *
 * This is an autogenerated file. DO NOT EDIT MANUALLY.
 * if you want to make changes, please update the grammar file and regenerate the code.
 *
 * Any manual modifications will be overwritten the next time the code is generated.
 */

/**
 * @typedef {Object} Loc
 * @property {number} line
 * @property {number} column
 * @property {number} cursor
 * @property {string} path
 */
class Loc {
  line;
  column;
  cursor;
  path;

  constructor(line = 0, column = 0, cursor = 0, path = "") {
    this.line = line;
    this.column = column;
    this.cursor = cursor;
    this.path = path;
  }
}

/**
 * @typedef {Object} Span
 * @property {Loc} start
 * @property {Loc} end
 */
class Span {
  start;
  end;

  constructor(start = new Loc(), end = new Loc()) {
    this.start = start;
    this.end = end;
  }
}

/**
 * @typedef {Object} ParseError
 * @property {string} expected
 * @property {string} message
 * @property {Span} span
 */
class ParseError extends Error {
  expected;
  message;
  span;

  /**
   * 
   * @param {string} expected
   * @param {string} message 
   * @param {Span} span 
   */
  constructor(expected, message, span) {
    super(message);
    this.expected = expected;
    this.message = message;
    this.span = span;
  }
}

/**
 * @typedef {Object} StringValue
 * @property {string} value
 * @property {Span} span
 */
class StringValue {
  value;
  span;

  /**
   * 
   * @param {string} value 
   * @param {Span} span 
   */
  constructor(value, span) {
    this.value = value;
    this.span = span;
  }
}


/**
 * @typedef {Object} SequenceValue
 * @property {Value[]} items
 * @property {Span} span
 */
class SequenceValue {
  items;
  span;


  /**
   * 
   * @param {Value[]} items 
   * @param {Span} span 
   */
  constructor(items, span) {
    this.items = items;
    this.span = span;
  }
}


/**
 * @typedef {Object} NodeValue
 * @property {string} name
 * @property {Value} expr
 * @property {Span} span
 */
class NodeValue {
  name;
  expr;
  span;

  constructor(name, expr, span) {
    this.name = name;
    this.expr = expr;
    this.span = span;
  }
}

/**
 * @typedef {StringValue | SequenceValue | NodeValue} Value
 */

/**
 * 
 * @param {unknown} input 
 * @returns {input is Value}
 */
function isValue(input) {
  return (
    input instanceof StringValue ||
    input instanceof SequenceValue ||
    input instanceof NodeValue
  );
}

/**
 * @typeparam {Var}
 * @typedef {<Var>() => Var} ParserFn<Var>
 */

/**
 * 
 * @param {ParserFn<Var | Var[]>[]} items
 * @returns {Var | Var[]}
 */
function narrow(items) {
  const output = [];
  for (const i of items) {
    const ii = i();
    if (ii !== null) {
      if (Array.isArray(ii)) {
        output.push(...ii);
      } else {
        output.push(ii);
      }
    }
  }

  if (output.length === 1) {
    return output[0];
  }
  return output;
}

/**
 * @typedef {Object} Parser
 * @property {string} string
 * @property {number} cursor
 * @property {number} line
 * @property {number} column
 * @property {string} path
 * @property {number} predicateLevel
 * @property {boolean} captureSpaces
 * @property {boolean} printTraceback
 * @property {Record<string, ParserFn<unknown>>} recoveryTable
 */
class Parser {
  string;
  cursor = 0;
  line = 0;
  column = 0;
  path = "";
  predicateLevel = 0;
  captureSpaces = false;
  printTraceback = false;
  recoveryTable = {};

  /**
   * 
   * @param {string} string 
   */
  constructor(string) {
    this.string = string;
  }


  /**
   * 
   * @param {ParserFn<unknown>} fn 
   */
  and(fn) {
    const start = this.location();

    try {
      fn();
      return;
    } catch {
      // noop
    } finally {
      this.backtrack(start);
    }

    throw new ParseError("&", "and", this.span(start));
  }

  /**
   * 
   * @param {ParserFn<unknown>} fn 
   */
  any() {
    const c = this.peek();
    this.cursor++;
    this.column++;

    if (c === "\n") {
      this.line++;
      this.column = 0;
    }

    return c;
  }

  /**
   * 
   * @param {Loc} position 
   */
  backtrack(position) {
    this.cursor = position.cursor;
    this.line = position.line;
    this.column = position.column;
  }

  /**
   * 
   * @param {ParserFn<unknown>[]} fns 
   */
  choice(fns) {
    const start = this.location();

    for (const fn of fns) {
      try {
        return fn();
      } catch (e) {
        this.backtrack(start);
      }
    }

    throw new ParseError("choice", "choice", this.span(start));
  }

  /**
   * 
   * @param {ParserFn<unknown>} fn 
   */
  oneOrMore(fn) {
    const head = [fn()];
    const tail = this.zeroOrMore(fn);

    return head.concat(tail);
  }

  /**
    * TODO: Not sure if this is the correct translation of the original code.
    * @param {ParserFn<unknown>} fn 
   */
  optional(fn) {
    return this.choice([fn, () => null]);
  }

  /**
   * 
   * @param {string} lit 
   */
  expectLiteral(lit) {
    const start = this.location();

    for (const i of lit) {
      const c = this.any();
      if (c === i) {
        continue;
      }

      const expected = `\`${c}\``;

      throw new ParseError(
        expected,
        `expected ${expected}, got \`${c}\``,
        this.span(start)
      );
    }

    return lit;
  }

  /**
   * 
   * @param {string} a 
   * @param {string} b 
   */
  expectRange(a, b) {
    const start = this.location();
    const c = this.peek();

    if (c >= a && c <= b) {
      return this.any();
    }

    const expected = `${a}-${b}`;

    throw new ParseError(
      expected,
      `expected ${expected}, got ${c}`,
      this.span(start)
    );
  }


  /**
   * 
   * @param {Loc} start 
   * @param {Var | Value | (Var | Value)[]} v 
   */
  location() {
    return new Loc(this.line, this.column, this.cursor, this.path);
  }

  /**
   * 
   * @param {Loc} start 
   * @param {Var | Value | (Var | Value)[]} v 
   */
  mk(start, v) {
    const span = this.span(start);

    if (Array.isArray(v)) {
      if (v.length === 1) {
        return this.mk(start, v[0]);
      }

      return new SequenceValue(v, span);
    }

    if (typeof v === "string") {
      return new StringValue(v, span);
    }

    return v;
  }

  /**
   * 
   * @param {string} name 
   * @param {Loc} start 
   * @param {Var | Value} expr 
   */
  mknode(name, start, expr) {
    const span = new Span(start, this.location());
    return new NodeValue(name, this.mk(start, expr), span);
  }

  /**
   * 
   * @param {ParserFn<unknown>} fn 
   */
  not(fn) {
    const start = this.location();

    try {
      fn();
    } catch (e) {
      return;
    } finally {
      this.backtrack(start);
    }

    throw new ParseError("!", "not", this.span(start));
  }

  peek() {
    const start = this.location();
    if (this.cursor === this.string.length) {
      throw new ParseError(".", "EOF", this.span(start));
    }

    return this.string[this.cursor];
  }


  
  parseAny() {
    const start = new Loc(this.line, this.column, this.cursor);

    return new StringValue(this.any(), this.span(start));
  }

  /**
   * 
   * @param {string} lit 
   */
  parseLiteral(lit) {
    const start = this.location();

    return new StringValue(this.expectLiteral(lit), this.span(start));
  }

  /**
   * 
   * @param {string} left 
   * @param {string} right 
   */
  parseRange(left, right) {
    const start = this.location();

    return new StringValue(this.expectRange(left, right), this.span(start));
  }

  parseSpacing() {
    throw new Error("Not implemented");
  }

  parseEof() {
    this.not(() => this.any());
  }

  /**
   * 
   * @param {Loc} start
   */
  span(start) {
    return new Span(start, this.location());
  }

  /**
   * 
   * @param {ParserFn<unknown>} fn 
   */
  zeroOrMore(fn) {
    const output = [];

    while (true) {
      const start = this.location();

      try {
        output.push(fn());
      } catch (e) {
        this.backtrack(start);
        break;
      }
    }

    return output;
  }
