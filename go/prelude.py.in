# source: {{.GrammarPath}}

# This is an autogenerated file. Check your build system and find the
# grammar to edit instead of editing this file directly, unless
# you're fine with changes getting erased.

from typing import Callable, TypeVar
from dataclasses import dataclass, field


@dataclass
class Location:
    line: int = 0
    column: int = 0
    cursor: int = 0
    path: str = ""


@dataclass
class Span:
    start: Location = field(default_factory=Location)
    end: Location = field(default_factory=Location)


@dataclass
class ParseError(Exception):
    expected: str = ""
    message: str = ""
    span: Span = field(default_factory=Span)


@dataclass
class Error(Exception):
    expected: str = ""
    message: str = ""
    span: Span = field(default_factory=Span)


@dataclass
class String:
    value: str
    span: Span


@dataclass
class Sequence:
    items: list['Value']
    span: Span


@dataclass
class Node:
    name: str
    expr: 'Value'
    span: Span


Value = String | Sequence | Node

Var = TypeVar('Var')

ParserFn = Callable[[], Var]


def narrow(items: list[ParserFn]) -> Var | list[Var]:
    output: list[Var] = []
    for i in items:
        ii = i()
        if ii is not None:
            output.append(ii)
    if len(output) == 1:
        return output[0]
    return output


@dataclass
class Parser:
    string: str
    cursor: int = 0
    line: int = 0
    column: int=  0
    path: str = ""
    predicate_level: int = 0
    capture_spaces: bool = False
    print_traceback: bool = False
    recovery_table: dict[str, ParserFn] = field(default_factory=dict)

    # def parse() -> Value:
    #     pass

    # def parse_space(self) -> Value:
    #     start = self.location()

    #     def spc_chr() -> Value:
    #         start = self.location()
    #         result = self.expect_charset([" ", "\t", "\r", "\n"])
    #         return String(result, self.span(start))

    #     spaces = self.zero_or_more(spc_chr)
    #     span = Span(start, self.location())
    #     return Node("Spacing", result, span)

    def parse_any(self) -> Value:
        start = self.location()
        return String(self.any(), self.span(start))

    def parse_range(self, left: str, right: str) -> Value:
        start = self.location()
        return String(self.expect_range(left, right), self.span(start))

    def parse_literal(self, lit) -> Value:
        start = self.location()
        return String(self.expect_literal(lit), self.span(start))

    def parse_eof(self):
        self.not_(lambda: self.parse_any())

    def expect_range(self, a: str, b: str) -> str:
        start = self.location()
        c = self.peek()
        if c >= a and c <= b:
            return self.any()

        expected = f"{a}-{b}"
        message = f"Expected {expected} but got `{c}`"
        raise Error(expected=expected, message=message, span=self.span(start))

    def expect_literal(self, lit: str) -> str:
        start = self.location()
        for i in lit:
            c = self.any()
            if i == c:
                continue

            expected = f"`{c}`"
            message = f"Expected `{i}` but got `{c}`"
            raise Error(expected=expected, message=message, span=self.span(start))
        return lit

    def not_(self, fn: ParserFn):
        start = self.location()
        try:
            fn()
        except Error:
            return
        finally:
            self.backtrack(start)
        raise Error(expected="!", message="not", span=self.span(start))

    def and_(self, fn: ParserFn):
        start = self.location()
        try:
            fn()
            return
        finally:
            self.backtrack(start)
        raise Error(expected="&", message="and", span=self.span(start))

    def choice(self, fns: list[ParserFn]) -> Var:
        start = self.location()
        for fn in fns:
            try:
                return fn()
            except Error:
                self.backtrack(start)
        raise Error(expected='choice', message="choice", span=self.span(start))

    def optional(self, fn: ParserFn) -> list[Var]:
        return self.choice([fn, lambda: None])

    def one_or_more(self, fn: ParserFn) -> list[Var]:
        head = [fn()]
        tail = self.zero_or_more(fn)
        return head + tail

    def zero_or_more(self, fn: ParserFn) -> list[Var]:
        output: list[Var] = []
        while True:
            start = self.location()
            try:
                output.append(fn())
            except Error:
                self.backtrack(start)
                break
        return output

    def any(self) -> str:
        c = self.peek()
        self.cursor += 1
        self.column += 1
        if c == '\n':
            self.column = 0
            self.line += 1
        return c

    def peek(self) -> str:
        start = self.location()
        if self.cursor == len(self.string):
            raise Error(expected='.', message="EOF", span=self.span(start))
        return self.string[self.cursor]

    def span(self, start) -> Span:
        return Span(start, self.location())

    def location(self) -> Location:
        return Location(self.line, self.column, self.cursor, self.path)

    def backtrack(self, position: Location):
        self.cursor = position.cursor
        self.line = position.line
        self.column = position.column

    def mk(self, start: Location, v: Var | Value) -> Value:
        span = Span(start, self.location())
        if isinstance(v, list):
            if len(v) == 1:
                return self.mk(start, v[0])
            return Sequence(v, span)
        if isinstance(v, str):
            return String(v, span)
        return v

    def mknode(self, name: str, start: Location, expr: Value) -> Value:
        span = Span(start, self.location())
        return Node(name, self.mk(start, expr), span)
