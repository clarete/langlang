/** Source: {{.GrammarPath}}
 *
 * This is an autogenerated file. DO NOT EDIT MANUALLY.  if you want
 * to make changes, please update the grammar file and regenerate the
 * code.
 *
 * Any manual modifications will be overwritten the next time the code
 * is generated.
 */

export class Loc {
  line: number;
  column: number;
  cursor: number;
  file: string;

  constructor(line = 0, column = 0, cursor = 0, file = "") {
    this.line = line;
    this.column = column;
    this.cursor = cursor;
    this.file = file;
  }

  String(): string {
    if (this.line == 0) {
      return `${this.column}`;
    }
    return `${this.line+1}:${this.column}`;
  }
}

export class Span {
  start: Loc;
  end: Loc;

  constructor(start = new Loc(), end = new Loc()) {
    this.start = start;
    this.end = end;
  }

  String(): string {
    let prefix = this.start.file;
    if (prefix != "") {
      prefix += ":"
    }

    if (this.start.line == this.end.line) {
      if (this.start.column == this.end.column) {
        return prefix + this.start.column;
      }
    }

    return `${prefix}${this.start.String()}..${this.end.String()}`
  }
}

export class ParseError extends Error {
  expected: string;
  span: Span;

  constructor(expected: string, span: Span) {
    super(`Missing \`${expected}\` @ ${span.String()}`);
    this.expected = expected;
    this.span = span;
  }
}

export class StringValue {
  value: string;
  span: Span;

  constructor(value: string, span: Span) {
    this.value = value;
    this.span = span;
  }

  text(): string {
    return this.value;
  }
}

export class SequenceValue {
  items: Value[];
  span: Span;

  constructor(items: Value[], span: Span) {
    this.items = items;
    this.span = span;
  }

  text(): string {
    let out = "";
    for (const item of this.items)
      out += item.text()
    return out;
  }
}

export class NodeValue {
  name: string;
  expr: Value;
  span: Span;

  constructor(name: string, expr: Value, span: Span) {
    this.name = name;
    this.expr = expr;
    this.span = span;
  }

  text(): string {
    return this.expr.text()
  }
}

type MEntry = {
  value: Value;
  error: Error;
  end: Loc;
}

export type Value = StringValue | SequenceValue | NodeValue;

function isValue(input: unknown): input is Value {
  return (
    input instanceof StringValue ||
    input instanceof SequenceValue ||
    input instanceof NodeValue
  );
}

export type ParserFn<T> = () => T;

export type ActionFn<T> = (node: NodeValue) => T;

type ValOrNil = Value | null;

function wrapSeq(items: ValOrNil[], span: Span): Value | null {
  switch (items.length) {
    case 0:
      return null;
    case 1:
      return items[0];
    default:
      return new SequenceValue(items, span);
  }
}

export class Parser {
  ffp: Number;
  cursor = 0;
  line = 0;
  column = 0;
  input: string;

  inputPath: string;
  grammarPath: string;

  lastError: Error;
  lastErrorFFP: number;
  predicateStackCount = 0
  labelMessages: Record<string, string> = {};
  actionFunctions: Record<string, ActionFn<unknown>> = {};
  
  captureSpaces = false;
  recoveryTable: Record<string, ParserFn<unknown>> = {};
  mtable: Record<string, MEntry> = {};

  constructor(input: string) {
    this.input = input;
  }

  and(fn: ParserFn<unknown>): null {
    const start = this.location();

    try {
      fn();
      return null;
    } catch {
      // noop
    } finally {
      this.backtrack(start);
    }

    throw new ParseError("&", this.span(start));
  }

  any(): string {
    const c = this.peek();
    this.cursor++;
    this.column++;

    if (c === "\n") {
      this.line++;
      this.column = 0;
    }

    return c;
  }

  backtrack(position: Loc) {
    this.cursor = position.cursor;
    this.line = position.line;
    this.column = position.column;
  }

  choice<Var>(fns: ParserFn<Var>[]): Var {
    const start = this.location();

    for (const fn of fns) {
      try {
        return fn();
      } catch (e) {
        this.backtrack(start);
      }
    }

    throw new ParseError("choice", this.span(start));
  }

  zeroOrMore<T>(fn: ParserFn<T>): T[] {
    const output: T[] = [];

    while (true) {
      const start = this.location();

      try {
        output.push(fn());
      } catch (e) {
        this.backtrack(start);
        break;
      }
    }
    return output;
  }

  oneOrMore<Var>(fn: ParserFn<Var>): Var[] {
    const head = [fn()];
    const tail = this.zeroOrMore(fn);
    return head.concat(tail);
  }

  optional<T>(fn: ParserFn<T>): T {
    return this.choice([fn, () => null]);
  }

  expectLiteral(lit: string): string {
    const start = this.location();

    for (const i of lit) {
      const c = this.any();
      if (c === i) {
        continue;
      }
      throw new ParseError(i, this.span(start));
    }

    return lit;
  }

  expectRange(a: string, b: string): string {
    const start = this.location();
    const c = this.peek();

    if (c >= a && c <= b) {
      return this.any();
    }

    const expected = `${a}-${b}`;

    throw new ParseError(expected, this.span(start));
  }

  location(): Loc {
    return new Loc(this.line, this.column, this.cursor, this.inputPath);
  }

  mk(start: Loc, v: Value | Value[]): Value {
    const span = this.span(start);

    if (Array.isArray(v)) {
      if (v.length === 1) {
        return this.mk(start, v[0]);
      }

      return new SequenceValue(v, span);
    }

    if (typeof v === "string") {
      return new StringValue(v, span);
    }

    return v as Value;
  }

  mknode(name: string, start: Loc, expr: Value): Value {
    const span = new Span(start, this.location());
    return new NodeValue(name, this.mk(start, expr), span);
  }

  not(fn: ParserFn<unknown>): null {
    const start = this.location();

    try {
      fn();
    } catch (e) {
      return null;
    } finally {
      this.backtrack(start);
    }

    throw new ParseError("!", this.span(start));
  }

  peek(): string {
    const start = this.location();
    if (this.cursor === this.input.length) {
      throw new ParseError(".", this.span(start));
    }
    return this.input[this.cursor];
  }

  parseAny(): Value {
    const start = new Loc(this.line, this.column, this.cursor);

    return new StringValue(this.any(), this.span(start));
  }

  parseLiteral(lit: string): Value {
    const start = this.location();
    const value = this.expectLiteral(lit);
    return new StringValue(value, this.span(start));
  }

  parseRange(left: string, right: string): Value {
    const start = this.location();
    const value = this.expectRange(left, right);
    return new StringValue(value, this.span(start));
  }

  parseSpacing(): Value {
    const start = this.location();
    const value = this.zeroOrMore(this.parseSpacingChar);
    if (!this.captureSpaces || value == null) {
      return null;
    }
    const end = this.span(start);
    const sequence = new SequenceValue(value, end);
    return new NodeValue("Spacing", sequence, end);
  }

  parseSpacingChar(): Value {
    const start = this.location();
    const value = this.choice([
      () => this.expectLiteral(" "),
      () => this.expectLiteral("\t"),
    ]);
    return new StringValue(value, this.span(start));
  }

  parseEOF(): null {
    this.not(() => this.any());
    return null
  }

  span(start: Loc): Span {
    return new Span(start, this.location());
  }

