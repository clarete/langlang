/** Source: {{.GrammarPath}}
 *
 * This is an autogenerated file. DO NOT EDIT MANUALLY.
 * if you want to make changes, please update the grammar file and regenerate the code.
 *
 * Any manual modifications will be overwritten the next time the code is generated.
 */

class Loc {
  line: number;
  column: number;
  cursor: number;
  path: string;

  constructor(line = 0, column = 0, cursor = 0, path = "") {
    this.line = line;
    this.column = column;
    this.cursor = cursor;
    this.path = path;
  }
}

class Span {
  start: Loc;
  end: Loc;

  constructor(start = new Loc(), end = new Loc()) {
    this.start = start;
    this.end = end;
  }
}

class ParseError extends Error {
  expected: string;
  message: string;
  span: Span;

  constructor(expected: string, message: string, span: Span) {
    super(message);
    this.expected = expected;
    this.message = message;
    this.span = span;
  }
}

class StringValue {
  value: string;
  span: Span;

  constructor(value: string, span: Span) {
    this.value = value;
    this.span = span;
  }
}

class SequenceValue {
  items: Value[];
  span: Span;

  constructor(items: Value[], span: Span) {
    this.items = items;
    this.span = span;
  }
}

class NodeValue {
  name: string;
  expr: Value;
  span: Span;

  constructor(name: string, expr: Value, span: Span) {
    this.name = name;
    this.expr = expr;
    this.span = span;
  }
}

type Value = StringValue | SequenceValue | NodeValue;

function isValue(input: unknown): input is Value {
  return (
    input instanceof StringValue ||
    input instanceof SequenceValue ||
    input instanceof NodeValue
  );
}

type ParserFn<Var> = () => Var;

function narrow<Var>(items: ParserFn<Var | Var[]>[]): Var | Var[] {
  const output: Var[] = [];
  for (const i of items) {
    const ii = i();
    if (ii !== null) {
      if (Array.isArray(ii)) {
        output.push(...ii);
      } else {
        output.push(ii);
      }
    }
  }

  if (output.length === 1) {
    return output[0];
  }
  return output;
}

class Parser {
  string: string;
  cursor = 0;
  line = 0;
  column = 0;
  path = "";
  predicateLevel = 0;
  captureSpaces = false;
  printTraceback = false;
  recoveryTable: Record<string, ParserFn<unknown>> = {};

  constructor(string: string) {
    this.string = string;
  }

  and(fn: ParserFn<unknown>): void {
    const start = this.location();

    try {
      fn();
      return;
    } catch {
      // noop
    } finally {
      this.backtrack(start);
    }

    throw new ParseError("&", "and", this.span(start));
  }

  any(): string {
    const c = this.peek();
    this.cursor++;
    this.column++;

    if (c === "\n") {
      this.line++;
      this.column = 0;
    }

    return c;
  }

  backtrack(position: Loc) {
    this.cursor = position.cursor;
    this.line = position.line;
    this.column = position.column;
  }

  choice<Var>(fns: ParserFn<Var>[]): Var {
    const start = this.location();

    for (const fn of fns) {
      try {
        return fn();
      } catch (e) {
        this.backtrack(start);
      }
    }

    throw new ParseError("choice", "choice", this.span(start));
  }

  oneOrMore<Var>(fn: ParserFn<Var>): Var[] {
    const head = [fn()];
    const tail = this.zeroOrMore(fn);

    return head.concat(tail);
  }

  /**
   * TODO: Not sure if this is the correct translation of the original code.
   */
  optional<Var>(fn: ParserFn<Var>): Var {
    return this.choice([fn, () => (null as unknown as Var)]);
  }

  expectLiteral(lit: string): string {
    const start = this.location();

    for (const i of lit) {
      const c = this.any();
      if (c === i) {
        continue;
      }

      const expected = `\`${c}\``;

      throw new ParseError(
        expected,
        `expected ${expected}, got \`${c}\``,
        this.span(start)
      );
    }

    return lit;
  }

  expectRange(a: string, b: string): string {
    const start = this.location();
    const c = this.peek();

    if (c >= a && c <= b) {
      return this.any();
    }

    const expected = `${a}-${b}`;

    throw new ParseError(
      expected,
      `expected ${expected}, got ${c}`,
      this.span(start)
    );
  }

  location(): Loc {
    return new Loc(this.line, this.column, this.cursor, this.path);
  }

  mk<Var>(start: Loc, v: (Var | Value) | (Var | Value)[]): Value {
    const span = this.span(start);

    if (Array.isArray(v)) {
      if (v.length === 1) {
        return this.mk(start, v[0]);
      }

      return new SequenceValue(v as Value[], span);
    }

    if (typeof v === "string") {
      return new StringValue(v, span);
    }

    return v as Value;
  }

  mknode(name: string, start: Loc, expr: Value): Value {
    const span = new Span(start, this.location());
    return new NodeValue(name, this.mk(start, expr), span);
  }

  not(fn: ParserFn<unknown>): void {
    const start = this.location();

    try {
      fn();
    } catch (e) {
      return;
    } finally {
      this.backtrack(start);
    }

    throw new ParseError("!", "not", this.span(start));
  }

  peek(): string {
    const start = this.location();
    if (this.cursor === this.string.length) {
      throw new ParseError(".", "EOF", this.span(start));
    }

    return this.string[this.cursor];
  }

  parseAny(): Value {
    const start = new Loc(this.line, this.column, this.cursor);

    return new StringValue(this.any(), this.span(start));
  }

  parseLiteral(lit: string): Value {
    const start = this.location();

    return new StringValue(this.expectLiteral(lit), this.span(start));
  }

  parseRange(left: string, right: string): Value {
    const start = this.location();

    return new StringValue(this.expectRange(left, right), this.span(start));
  }

  parseSpacing(): Value {
    throw new Error("Not implemented");
  }

  parseEof(): void {
    this.not(() => this.any());
  }

  span(start: Loc): Span {
    return new Span(start, this.location());
  }

  zeroOrMore<Var>(fn: ParserFn<Var>): Var[] {
    const output: Var[] = [];

    while (true) {
      const start = this.location();

      try {
        output.push(fn());
      } catch (e) {
        this.backtrack(start);
        break;
      }
    }

    return output;
  }
