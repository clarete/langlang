/** Source: {{.GrammarPath}}
 *
 * This is an autogenerated file. DO NOT EDIT MANUALLY.  if you want
 * to make changes, please update the grammar file and regenerate the
 * code.
 *
 * Any manual modifications will be overwritten the next time the code
 * is generated.
 */

export class Loc {
  line: number;
  column: number;
  cursor: number;
  path: string;

  constructor(line = 0, column = 0, cursor = 0, path = "") {
    this.line = line;
    this.column = column;
    this.cursor = cursor;
    this.path = path;
  }
}

export class Span {
  start: Loc;
  end: Loc;

  constructor(start = new Loc(), end = new Loc()) {
    this.start = start;
    this.end = end;
  }
}

export class ParseError extends Error {
  expected: string;
  message: string;
  span: Span;

  constructor(expected: string, message: string, span: Span) {
    super(message);
    this.expected = expected;
    this.message = message;
    this.span = span;
  }
}

export class StringValue {
  value: string;
  span: Span;

  constructor(value: string, span: Span) {
    this.value = value;
    this.span = span;
  }
}

export class SequenceValue {
  items: Value[];
  span: Span;

  constructor(items: Value[], span: Span) {
    this.items = items;
    this.span = span;
  }
}

export class NodeValue {
  name: string;
  expr: Value;
  span: Span;

  constructor(name: string, expr: Value, span: Span) {
    this.name = name;
    this.expr = expr;
    this.span = span;
  }
}

type MEntry = {
  value: Value;
  error: Error;
  end: Loc;
}

export type Value = StringValue | SequenceValue | NodeValue | null;

function isValue(input: unknown): input is Value {
  return (
    input instanceof StringValue ||
    input instanceof SequenceValue ||
    input instanceof NodeValue
  );
}

export type ParserFn<T> = () => T;

export type ActionFn<T> = (node: NodeValue) => T;

function narrow<T>(items: ParserFn<T | T[]>[]): T | T[] {
  const output: T[] = [];
  for (const i of items) {
    const ii = i();
    if (ii !== null) {
      if (Array.isArray(ii)) {
        output.push(...ii);
      } else {
        output.push(ii);
      }
    }
  }

  if (output.length === 1) {
    return output[0];
  }
  return output;
}

function wrapSeq(items: Value[], span: Span): Value | null {
  switch (items.length) {
    case 0:
      return null;
    case 1:
      return items[0];
    default:
      return new SequenceValue(items, span);
  }
}

export class Parser {
  ffp: Number;
  cursor = 0;
  line = 0;
  column = 0;
  input: string;

  inputPath: string;
  grammarPath: string;

  lastError: Error;
  lastErrorFFP: number;
  predicateStackCount = 0
  labelMessages: Record<string, string> = {};
  actionFunctions: Record<string, ActionFn<unknown>> = {};
  
  captureSpaces = false;
  recoveryTable: Record<string, ParserFn<unknown>> = {};
  mtable: Record<string, MEntry> = {};

  constructor() {}

  and(fn: ParserFn<unknown>): void {
    const start = this.location();

    try {
      fn();
      return;
    } catch {
      // noop
    } finally {
      this.backtrack(start);
    }

    throw new ParseError("&", "and", this.span(start));
  }

  any(): string {
    const c = this.peek();
    this.cursor++;
    this.column++;

    if (c === "\n") {
      this.line++;
      this.column = 0;
    }

    return c;
  }

  backtrack(position: Loc) {
    this.cursor = position.cursor;
    this.line = position.line;
    this.column = position.column;
  }

  choice<Var>(fns: ParserFn<Var>[]): Var {
    const start = this.location();

    for (const fn of fns) {
      try {
        return fn();
      } catch (e) {
        this.backtrack(start);
      }
    }

    throw new ParseError("choice", "choice", this.span(start));
  }

  zeroOrMore<T>(fn: ParserFn<T>): T[] {
    const output: T[] = [];

    while (true) {
      const start = this.location();

      try {
        output.push(fn());
      } catch (e) {
        this.backtrack(start);
        break;
      }
    }
    return output;
  }

  oneOrMore<Var>(fn: ParserFn<Var>): Var[] {
    const head = [fn()];
    const tail = this.zeroOrMore(fn);
    return head.concat(tail);
  }

  optional<T>(fn: ParserFn<T>): T {
    return this.choice([fn, () => null]);
  }

  expectLiteral(lit: string): string {
    const start = this.location();

    for (const i of lit) {
      const c = this.any();
      if (c === i) {
        continue;
      }

      const expected = `\`${c}\``;

      throw new ParseError(
        expected,
        `expected ${expected}, got \`${c}\``,
        this.span(start)
      );
    }

    return lit;
  }

  expectRange(a: string, b: string): string {
    const start = this.location();
    const c = this.peek();

    if (c >= a && c <= b) {
      return this.any();
    }

    const expected = `${a}-${b}`;

    throw new ParseError(
      expected,
      `expected ${expected}, got ${c}`,
      this.span(start)
    );
  }

  location(): Loc {
    return new Loc(this.line, this.column, this.cursor, this.inputPath);
  }

  mk(start: Loc, v: Value | Value[]): Value {
    const span = this.span(start);

    if (Array.isArray(v)) {
      if (v.length === 1) {
        return this.mk(start, v[0]);
      }

      return new SequenceValue(v, span);
    }

    if (typeof v === "string") {
      return new StringValue(v, span);
    }

    return v as Value;
  }

  mknode(name: string, start: Loc, expr: Value): Value {
    const span = new Span(start, this.location());
    return new NodeValue(name, this.mk(start, expr), span);
  }

  not(fn: ParserFn<unknown>): void {
    const start = this.location();

    try {
      fn();
    } catch (e) {
      return;
    } finally {
      this.backtrack(start);
    }

    throw new ParseError("!", "not", this.span(start));
  }

  peek(): string {
    const start = this.location();
    if (this.cursor === this.input.length) {
      throw new ParseError(".", "EOF", this.span(start));
    }
    return this.input[this.cursor];
  }

  parseAny(): Value {
    const start = new Loc(this.line, this.column, this.cursor);

    return new StringValue(this.any(), this.span(start));
  }

  parseLiteral(lit: string): Value {
    const start = this.location();
    const value = this.expectLiteral(lit);
    return new StringValue(value, this.span(start));
  }

  parseRange(left: string, right: string): Value {
    const start = this.location();
    const value = this.expectRange(left, right);
    return new StringValue(value, this.span(start));
  }

  parseSpacing(): Value {
    const start = this.location();
    const value = this.zeroOrMore(this.parseSpacingChar);
    if (!this.captureSpaces || value == null) {
      return null;
    }
    const end = this.span(start);
    const sequence = new SequenceValue(value, end);
    return new NodeValue("Spacing", sequence, end);
  }

  parseSpacingChar(): Value {
    const start = this.location();
    const value = this.choice([
      () => this.expectLiteral(" "),
      () => this.expectLiteral("\t"),
    ]);
    return new StringValue(value, this.span(start));
  }

  parseEOF(): void {
    this.not(() => this.any());
  }

  span(start: Loc): Span {
    return new Span(start, this.location());
  }

