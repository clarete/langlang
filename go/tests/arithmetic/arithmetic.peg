// A mini expression language WITHOUT left recursion, using the
// traditional PEG approach with separate rules per precedence level.
// This is the non-left-recursive counterpart to arithmetic_leftrec.

Program    <- Stmt+ EOF
Stmt       <- LetStmt / IfStmt / ExprStmt
LetStmt    <- 'let' Identifier '='^leteq Expr^letexpr ';'^letsemi
IfStmt     <- 'if' '('^iflpar Expr^ifexpr ')'^ifrpar '{' Stmt* '}'^ifrcurl
ExprStmt   <- Expr ';'^exprsemi

// Non-left-recursive expression with 7 precedence levels
// using repetition (*) for left-associative operators:
//   1: || (logical or, lowest precedence)
//   2: && (logical and)
//   3: ==, != (equality)
//   4: <=, >=, <, > (comparison)
//   5: +, - (additive)
//   6: *, /, % (multiplicative)
//   7: unary - (negation)
// Atoms: Number, Identifier, '(' Expr ')'

Expr               <- LogicalOrExpr
LogicalOrExpr      <- LogicalAndExpr ('||' LogicalAndExpr)*
LogicalAndExpr     <- EqualityExpr ('&&' EqualityExpr)*
EqualityExpr       <- ComparisonExpr (('==' / '!=') ComparisonExpr)*
ComparisonExpr     <- AdditiveExpr (('<=' / '>=' / '<' / '>') AdditiveExpr)*
AdditiveExpr       <- MultiplicativeExpr (('+' / '-') MultiplicativeExpr)*
MultiplicativeExpr <- UnaryExpr (('*' / '/' / '%') UnaryExpr)*
UnaryExpr          <- '-' UnaryExpr / PrimaryExpr
PrimaryExpr        <- Number / Identifier / '(' Expr ')'^closeparen

Number     <- #([1-9][0-9]* / '0')
Identifier <- !Keywords #([a-zA-Z_][a-zA-Z0-9_]*)
Keywords   <- 'let' / 'if'

// Recovery expressions
leteq      <- (!Expr .)*
letexpr    <- (!';' .)*
letsemi    <-
iflpar     <- (!Expr .)*
ifexpr     <- (!(')' / '{') .)*
ifrpar     <- (!('{') .)*
ifrcurl    <-
exprsemi   <-
closeparen <- (!(';' / '}' / EOF) .)*

