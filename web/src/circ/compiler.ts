import type { LangLangValue } from "@langlang/react";
import { type AbstractSyntaxTree, assertCallNode, assertCircuitNode, assertProgramNode, assertReferenceNode, type CallNode, translate } from "./tree";




function wrapCircProgramBootstrap(code: string) {
    return `/// Auto-generated Circuit program
/// Do not edit this file directly.
/// Generated by LangLang


const std = @import("std");
const transport = @import("lib/transport.zig");
const memory = @import("lib/memory.zig");

const Circuit = @import("lib/circuit.zig").Circuit;
const Component = @import("lib/circuit.zig").Component;

const log = std.log.scoped(.log);

pub fn main() !void {
    defer memory.deinit();

    var circuit = try Circuit.init();
    defer circuit.deinit();
    
    ${code}
}`;
}

const builtInsMap = {
    std: {
        pin: '.input_pin_gate = .{}',
        led: '.led = .{}',
        wire: '.wire = .{ .inputs = .{}',
        and: '.and_gate = .{}',
        not: '.not_gate = .{}'
    }
}

function getBuiltIn(sequence: string[]): string {
    let context = builtInsMap;
    const breadCrumbs: string[] = []

    for (const route of sequence) {
        breadCrumbs.push(route);

        if (!(route in context)) {
            throw new Error(`${breadCrumbs.join('.')}`)
        }

        // @ts-expect-error - dynamic access
        context = context[route];
    }

    return context as unknown as string;
}

const builtInCallGenerators: Record<string, (ast: CallNode) => string> = {
    connect: (ast: CallNode) => {
        const { parameters } = ast;

        const paramsCode = parameters.map(({ address, port }) => {
            if (!port) {
                throw new Error('Port is required for connect calls');
            }
            return `${address.join('.')}, ${port}`;
        });

        return `try circuit.connect(${paramsCode.join(', ')});`
    }
}

const codeGenerators: Record<string, (ast: AbstractSyntaxTree) => string> = {
    circuit(ast: AbstractSyntaxTree) {
        assertCircuitNode(ast);

        const value = codeGenerator(ast.value);

        return `const ${ast.identifier} = try circuit.createComponent(.{ ${value} });`
    },
    program(ast: AbstractSyntaxTree) {
        assertProgramNode(ast);
        const texts = ast.texts.map(codeGenerator).filter(Boolean).join('\n    ');

        return texts;
    },
    ref(ast: AbstractSyntaxTree) {
        assertReferenceNode(ast);

        const { address, port } = ast;

        const portSufix = port ? `[${port}]` : '';

        try {
            return `${getBuiltIn(address)}${portSufix}`;
        } catch {
            const identifier = address.join('.');
            return `${identifier}${portSufix}`;
        }

    },
    call(ast: AbstractSyntaxTree) {
        assertCallNode(ast);

        const generator = builtInCallGenerators[ast.name];

        if (generator === undefined) {
            throw new Error(`No built-in call generator for: ${ast.name}`);
        }

        return generator(ast);
    }
}

function codeGenerator(ast: AbstractSyntaxTree) {
    const generator = codeGenerators[ast.type];

    if (generator === undefined) {
        throw new Error(`No code generator for call: ${ast.type}`);
    }

    return generator(ast);
}

export function compileZig(tree: LangLangValue) {
    const ast = translate(tree);
    const programText = codeGenerator(ast);
    const sourceCode = wrapCircProgramBootstrap(programText);

    return sourceCode;
}



